{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Make with boards","text":"<p>These projects assume you've never before used boards such as Raspberry Pi or Arduino, have little to no programming knowledge, aren't particularly aligned towards tinkering with machines unless no one else is around to do so, and have used only Windows laptops. Like me.</p> <p></p> <p>These projects are beginner-friendly and practical. They require no soldering.</p>"},{"location":"_includes/bash_security_camera/","title":"Bash security camera","text":""},{"location":"_includes/bash_security_camera/#write-the-bash-code-for-the-surveillance-camera","title":"Write the bash code for the surveillance camera","text":"<p>A surveillance camera continuously records the happenings that it can 'see'. For this project, this job will be done by a bash script.</p> <p>The operating system that you installed on the Raspberry Pi already includes <code>libcamera</code>, which is the package that will be used for recording videos.</p> <ol> <li>Switch on the Raspberry Pi and wait for the green light to stop flashing.</li> <li>Log in remotely to your Raspberry Pi by using Connect:<ol> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, you should see your Raspberry Pi. If it isn't, wait for a few minutes and refresh the page.  Then, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should then see the Raspberry Pi desktop in your laptop browser window.</li> </ol> </li> <li>Install any patches, fixes, and upgrades that might have been made to the operating system by opening the Raspberry Pi terminal window (the console icon near the top left) and running the following two commands one after the other:<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt-get upgrade</code></li> </ul> </li> <li>Open a terminal window by clicking the Terminal icon near the top left. At the prompt, go to the <code>Videos</code> directory by typing the following command: <code>cd ~/Videos</code>. This is the directory that will contain the bash script and the videos.</li> <li>Open a new file by typing the following command: <code>nano simplevideo.sh</code>. The built-in code editor, called <code>nano</code>, opens. </li> <li>Copy into it the code from The script section of this page. Then, save the file and exit from the nano editor by doing these steps:<ol> <li>Press Ctrl + O. The editor displays the name that the file should be saved with. You've already specified it to be <code>simplevideo.sh</code>.</li> <li>Press Enter. The file is saved.</li> <li>Press Ctrl + X. You're taken back to the command prompt.</li> </ol> </li> <li>Turn the bash script into an executable file by typing the following command: <code>chmod +x simplevideo.sh</code>.</li> <li>Run the file by typing the following command: <code>./simplevideo.sh</code>. You should start seeing some messages on the screen.</li> </ol> <p>Go to the directory where your videos are being saved (Click the File Manager icon near the top left, right next to the Raspberry Pi icon). To view the video file, double-click the file.</p> <p>To stop the video recording at any time, in the terminal window, press Ctrl + C. If you see the script automatically start recording again, press Ctrl + C again. (This is expected behaviour. How to handle this behaviour better is explained in the \"Refine the project\" section.)</p>"},{"location":"_includes/bash_security_camera/#the-script","title":"The script","text":"<p><pre><code>#!/bin/bash\nSAVE_PATH=\"/home/oracle/Videos\"\nmkdir -p \"$SAVE_PATH\"\n\nDURATION=$((60 * 1000))  # 1 minute in milliseconds\nwhile true; do\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout $DURATION -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\"\ndone\n</code></pre> You can also download the code file.</p> <p>Notice the second line of the script.</p> <pre><code>SAVE_PATH=\"/home/oracle/Videos\"\n</code></pre> <p>This is where you specify the directory to save the videos to. Replace <code>oracle</code> with the user name that you set up the Raspberry Pi with.</p> <p>Notice the next line:</p> <pre><code>DURATION=$((60 * 1000))  # 1 minute in milliseconds\n</code></pre> <p>The duration tells the script how long each video should be.</p> <p>Now look at the last bit:</p> <pre><code>libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout $DURATION -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\"\n</code></pre> <p>What's happening here that a video is being saved every 1 minute to the location you specified.</p> <ul> <li><code>libcamera-vid</code>: This is part of the Raspberry Pi's <code>libcamera</code> stack, and it handles video recording.</li> <li><code>--nopreview</code>: Tells the system not to open a preview window because the script in running in the background in headless mode.</li> <li><code>--width 640 --height 480</code>: Sets the video resolution to 640\u00d7480 pixels. A lower resolution means smaller files and faster processing. You could change this to <code>--width 1280 --height 720</code> or higher for better quality but doing so uses up more computer resources.</li> <li><code>--bitrate 1000000</code>: Sets the video compression level to 1,000,000 bits per second (that is, 1 Mbps). A higher bitrate means better video quality but larger files. For better visuals, you could increase this to 3000000.</li> <li><code>----timeout $DURATION</code>: This sets how long the video recording lasts in milliseconds. You've already specified the value through the <code>$DURATION</code> variable.</li> <li><code>-o \"$SAVE_PATH/ve_$TIMESTAMP.h264\"</code>: Specifies where to save the video file and with what name. <code>\"$SAVE_PATH\"</code> is a variable holding your directory (for example, <code>/home/oracle/Pictures</code>). <code>ve_$TIMESTAMP.h264</code> names the file with a timestamp (like <code>ve_20250420_135030.h264</code>). <code>.h264</code> is the raw video format. You can convert it to <code>.mp4</code> if needed.</li> </ul>"},{"location":"_includes/bash_security_camera/#troubleshooting-the-code","title":"Troubleshooting the code","text":"<p>No output</p> <p>If you don't see any <code>test.jpg</code> in the <code>Videos</code> directory, or if you don't see any messages on the terminal window, it's likely that the <code>libcamera</code> package wasn't installed properly. Reinstall it by running the following commands one after the other.</p> <ol> <li>Remove the existing packages: <code>sudo apt purge libcamera0 libcamera-apps libcamera-ipa libcamera0.4</code>.</li> <li>Clean up the cache: <code>sudo apt autoremove</code> and then <code>sudo apt clean</code>.</li> <li>Update the package list: <code>sudo apt update</code>.</li> <li>Install everything afresh: <code>sudo apt install libcamera-apps</code>.</li> </ol>"},{"location":"_includes/download_ip_scanner/","title":"Download ip scanner","text":"<p>Download Angry IP Scanner. If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. To do so, you need the IP address of the Raspberry Pi. A network scanner can show you the IP addresses of all devices that are connected to your network. One such network scanner is Angry IP Scanner, so download it.</p>"},{"location":"_includes/download_pi_imager/","title":"Download pi imager","text":"<p>Download Raspberry Pi Imager. The good folks at Raspberry Org have created a wizard that can install an operating system on a microSD card and also, simultaneously, configure the operating system with the barest minimum parameters that are needed to get a Raspberry Pi computer up and running. This wizard is known as Raspberry Pi Imager. </p>"},{"location":"_includes/download_putty/","title":"Download putty","text":"<p>Download PuTTY.  If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. One of the ways to do so is by using a secure shell (SSH) connection. PuTTY is an SSH client through which you can interactively run a command-line session on your Raspberry Pi. </p>"},{"location":"_includes/download_sdcardformatter/","title":"Download sdcardformatter","text":"<p>Download SD Memory Card Formatter. Before you can load an operating system on your microSD card, you must format it. Use the formatter provided by the SD Association because this formatter is platform-agnostic. </p>"},{"location":"_includes/download_winscp/","title":"Download winscp","text":"<p>Download WinSCP. If you need to transfer files to and from the Raspberry Pi computer, you need a secure file-transfer client. WinSCP is one such client. </p>"},{"location":"_includes/install_os/","title":"Install os","text":""},{"location":"_includes/install_os/#download-the-operating-system","title":"Download the operating system","text":"<p>For this step, you need a microSD card and a card reader that can be plugged into your laptop.</p> <p>The operating system will be downloaded on to the microSD card, which will then be inserted into the microSD slot of the Raspberry Pi board, which will then be plugged into a power socket. That's what will get the little board up and running, and make it ready for the final steps of the project.</p> <ol> <li>Turn on your laptop. Make sure that it is connected to the internet.</li> <li>Plug the microSD card into your laptop, and format it by running SD Card Formatter. Use the Overwrite option to format; this option takes longer but ensures that everything on the SD card is wiped clean and the card formatted.</li> <li>On the laptop, run the Raspberry Pi Imager wizard and download Raspberry Pi's operating system to it. All Raspberry Pi computers run on  operating systems that are based on the open-source Debian operating system. This project uses Debian Bookworm with the Raspberry Pi Desktop. Begin the download process by selecting the model as {{ pimodel }} and the operating system as {{ pios }}.</li> <li>On the page for OS customisation, click Edit settings. These settings are used for configuring the operating system with your credentials and environment. If prompted for loading Wi-Fi credentials from your host computer, respond in the affirmative. Then, specify the values for at least the following parameters. It's also a good idea to note down these values for easy reference, because you'll need these values later:<ul> <li>On the General page:<ul> <li>hostname, which is a name you call your Raspberry Pi by. This is the name that'll be displayed when you search for your Raspberry Pi on the network later.</li> <li>username and password, which are the credentials to use when logging in to Raspberry Pi remotely. The user name that you specify here will have administrator privileges to your Raspberry Pi.</li> <li>Wireless LAN, which should be prepopulated because you already asked the Wi-Fi credentials to be loaded from the host computer.</li> <li>Locale settings, for your time zone, keyboard preferences, and other such locale-related things.</li> </ul> </li> <li>On the Services page, select the Enable SSH box and the option for password authentication. Later, when the project is up and running, you might choose to isolate your Raspberry Pi from the network, and if you decide to do that, you can turn SSH off, but for the time being, enable it because you might need it for troubleshooting purposes.</li> <li>On the Options page, select all the options.</li> </ul> </li> <li>Click Save and, when prompted for applying these settings, answer in the affirmative. Click Yes again, and then wait for the operating system to be copied on to the microSD card.</li> <li>When the process is complete, take the microSD card out of the laptop port.</li> </ol>"},{"location":"_includes/install_raspi_connect/","title":"Install raspi connect","text":"<ol> <li>Set up Raspberry Pi Connect so that you can control the Raspberry Pi through a browser by using the Raspberry Pi's desktop GUI itself. At the moment, you're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal of the Raspberry Pi: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal of the Raspberry Pi: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in.</li> </ol> </li> </ol>"},{"location":"_includes/photo_frame_refine/","title":"Photo frame refine","text":""},{"location":"_includes/photo_frame_refine/#refine-the-project","title":"Refine the project","text":"<p>Now that your digital photo frame is working, consider incorporating the following enhancements to your project.</p> <ul> <li>Never go to sleep</li> <li>Touch to stop</li> <li>Pull from the cloud</li> <li>Make a stand</li> </ul>"},{"location":"_includes/photo_frame_refine/#never-go-to-sleep","title":"Never go to sleep","text":"<p>Disable the screen blanking function of the Raspberry Pi. The screen can turn completely black after a period of inactivity. This means, if you start the Python program and then leave it on to loop through your pictures continuously, what might happen is that the screen will eventually turn blank. The Raspberry Pi is still on (and it hasn't gone to sleep), and the Python program is still running, but the screen is black because of inactivity.</p> <p>For this project, you installed Debian Bookworm on Raspberry Pi 3. By default, screen blanking is turned off in Debian Bookworm, so you shouldn't need to do anything further, but just for peace of mind, ensure that it's really turned off. Click the Raspberry Pi icon near the top of the screen, and then click Preferences &gt; Raspberry Pi Configuration &gt; Display. The screen blanking option should be turned off, similar to what's shown in the following image:</p> <p> To see a larger image, click the image.</p>"},{"location":"_includes/photo_frame_refine/#touch-to-stop","title":"Touch to stop","text":"<p>Add a touch button to stop the Python script. The script you're using now can be stopped by pressing the <code>Esc</code> key on a keyboard, but you might not always have the USB receiver for the keyboard plugged into the Raspberry Pi. Stopping the script might become necessary in the following situations:</p> <ul> <li>To power down the Raspberry Pi.</li> <li>To load more photos on to the flash drive, in which case you must eject the drive, load the files into it, and then insert it back into the Raspberry Pi.</li> </ul> <p>Here's the code with stop-on-touch function. </p> <p>Notice the lines 44 through 50. These lines contain the code to stop the program with a touch or by clicking the left mouse-button. You add a small blue square near the bottom left corner, and you bind this square to the Stop action.</p> <pre><code># Add a blue button for touchscreen stop functionality\ndef stop_program(event):\n    root.destroy()\n# Create an overlay in the top-left corner (25x25 pixels) to detect touch\ntouch_exit_area = tk.Frame(root, width=25, height=25, bg=\"blue\")  # Blue for visibility purposes\ntouch_exit_area.place(x=0, y=0)\ntouch_exit_area.bind(\"&lt;Button-1&gt;\", stop_program)  # Bind left mouse button or touchscreen press\n</code></pre>"},{"location":"_includes/photo_frame_refine/#pull-from-the-cloud","title":"Pull from the cloud","text":"<p>Have the Python display loop also include photos from a cloud drive.</p>"},{"location":"_includes/photo_frame_refine/#make-a-stand","title":"Make a stand","text":"<p>Put the entire assembly into a case or stand. Doing so not only protects the computer boards from dust, but also gives support to the assembly so that it can stand on its own, without you having to use books or other such objects as props. I used a Multicomp Pro case, which was the only case available in my part of the world. Other options are a Pimoroni stand or a 3-D printed case from the designs at thingiverse.com.</p>"},{"location":"_includes/pi_3b_attach_display/","title":"Pi 3b attach display","text":""},{"location":"_includes/pi_3b_attach_display/#attach-a-touch-display-to-the-raspberry-pi-board","title":"Attach a touch display to the Raspberry Pi board","text":"<p>The Raspberry Pi is what they call an SBC (a single board computer). It has neither a screen where you can see the output of your commands, nor a keyboard through which you can send these commands to the computer. It is just a barebones computer, with no peripheral devices such as keyboard, mouse, monitor, speaker, or microphone. To use a Raspberry Pi as a computer, you must manually attach these peripherals to it. </p> <p>Here, you're not going to use the Raspberry Pi as a computer, but you are building a photo frame. Therefore, the barest minimum peripheral device that you need is a display screen.</p> <p>These are the materials that you need.</p> Front viewBack view <p> To see a larger image, click the image. </p> <p> To see a larger image, click the image. </p> <p>Notice the left side of both the images. At the top left quadrant is the Raspberry Pi board. At the bottom left is the power supply, the heat sinks, and the microSD card. These objects, when put together, constitute a standalone Raspberry Pi computer that you can use to do...stuff. Like building a digital photo frame.</p> <p>Look at the right half of both the images. The objects there are what's included in an official pack of the Raspberry Pi Touch Display. When plugged into a Raspberry Pi computer (which you can assemble from the materials at the left), this set becomes the display unit for the Raspberry Pi computer. </p> <p>Notice the view of the display screen from the back (second image, upper right quadrant).  The green board, called the controller board, has four little screws at the four corners. To mount the display screen on to the Raspberry Pi, you loosen these four screws at the four ends of the controller board of the display screen, place the Raspberry Pi on to it, and put the screws back in place.</p> <p>You then connect these two boards by means of two wires (red and black) and a cable (the white straight strip), which you can see at the bottom right quadrant of the images. Two things to note here:</p> <ul> <li>You don't need the shiny curved strip also shown in the picture; it came as standard packaging with the display and is used in Raspberry Pi 4 models. The model being used here, in this project, is Raspberry Pi 3B+, so the straight white strip is the one to use. In the Raspberry Pi world, strips like these are known as ribbon cables.</li> <li>You also don't need the yellow wire and the green wire. In the Raspberry Pi world, this kind of wire is called a jumper cable. Your photo frame uses a Raspberry Pi 3B+, which needs only two jumper cables, the red and the black. The yellow and green jumper cables are needed only if you're using an older model of the Raspberry Pi, one that does not have a 40-pin GPIO strip. For this tutorial, the GPIO pins aren't the focus so they won't be discussed, but if you're curious, you can read up on <code>GPIO</code>, <code>SCL</code>, and <code>SDA</code> pins.</li> </ul> <p>When you're done with attaching the display screen to the Raspberry Pi, the entire assembly should look something like this image (taken from <code>https://www.raspberrypi.com/documentation/accessories/display.html</code>):</p> <p> To see a larger image, click the image.</p> <p>I found this YouTube video helpful. It shows the steps to attach the display screen to the Raspberry Pi board.</p> <p>If you'd rather read some written instructions, see this official guide from the good folks at Raspberry Org: Touch Display.</p> <p>After the display screen is mounted on the computer board, fix the heat sinks.</p>"},{"location":"_includes/pi_3b_attach_heatsink/","title":"Pi 3b attach heatsink","text":""},{"location":"_includes/pi_3b_attach_heatsink/#fix-heat-sinks-to-the-raspberry-pi-board","title":"Fix heat sinks to the Raspberry Pi board","text":"<p>A heat sink is a square, metal object that is attached to a Raspberry Pi board by means of thermal paste. It draws the heat away from the processor, the USB controller, and the ethernet controller. A photo frame program running on a Raspberry Pi 3B+ should not heat the little computer too much, but it is safe practice to use heat sinks. </p> <p>The three small corrugated squares that you see at the bottom left of the image are heat sinks. In the Raspberry Pi world, these corrugations are known as fins.</p> <p> To see a larger image, click the image.</p> <p>Notice that the image shows three heat sinks.  A Raspberry Pi Model 3B+ needs only two of those. It's the Raspberry Pi 4 model that would've needed all three heat sinks, but because these heat sinks hardly cost anything, shops in my corner of the world usually sell them in sets of 3.</p> <p>Attach the heat sinks to the CPU chip and the network chip of the Raspberry Pi board. The one that goes over the CPU chip is the largest one; the one to use on the ethernet board is the smallest one.</p> <ol> <li>Peel off the adhesive strip at the back of the heat sink, all the while taking care that you don't touch the sticky part that the strip was covering. The sticky part is the thermal paste that will hold the sink in place.</li> <li>Press the sink ever so slightly on to the chip on the Raspberry Pi board.</li> </ol> <p>I found this YouTube video to be helpful.</p> <p>After the heat sinks are in place, prepare your laptop for the Raspberry Pi setup.</p>"},{"location":"_includes/pi_3b_install_os/","title":"Pi 3b install os","text":""},{"location":"_includes/pi_3b_install_os/#install-the-operating-system","title":"Install the operating system","text":"<p>For this project, you install the operating system called {{ pios }} for the model called {{ pimodel }}.</p> <ol> <li>Insert the microSD card to the Raspberry Pi's board, plug in the power adapter to a wall socket, and insert the cable into the USB-C power slot of the Raspberry Pi. If you're going to use an external keyboard and mouse, insert the USB receivers for these devices into the USB ports of the Raspberry Pi.</li> <li>Turn on the power switch of the wall socket. The light on the Raspberry Pi board should glow green, and the display screen should first show a rectangle of rainbow colours, and then finally show you the Raspberry Pi desktop screen.</li> <li>If you don't have an external keyboard and mouse, log in to the Raspberry Pi from your laptop:<ol> <li>Find the IP address of your nework gateway. To do so, on your laptop, open the command prompt, and type <code>ipconfig</code>. Then, note down the value that's displayed as Default Gateway.</li> <li>Start Angry IP Scanner. For the first box in the IP Range field, specify the value of the default gateway that you noted down in the previous step. For the second field, specify a number that's about 15-20 stops away. For example, if your default gateway is <code>192.168.4.1</code>, specify the end range to be something around <code>192.168.4.15</code>, so that the scan doesn't take too long. (The assumption here is that you don't already have more than 15-20 devices connected to your network!) Click Start and wait for the scan to be over. Then, in the Hostname column, look for the name of your Raspberry Pi. This is the name that you specified as the hostname in the OS Customisation settings while downloading the operating system on the microSD card. When you've spotted this hostname, look for the entry in the IP column. You need this value in the next step.</li> <li>On your laptop, start PuTTY and enter the IP address of your Raspberry Pi. This is the value that you noted down in your previous step. Click Open. When prompted for login credentials, enter the user name and password that you specified in the OS Customisation settings while downloading the operating system on the microSD card. You should now see a prompt like this: <code>&lt;hostname&gt;@&lt;username&gt;:~ $</code>. For example, if your hostname is <code>delphi</code> and user name is <code>oracle</code>, you'll see <code>delphi@oracle:~ $</code>It means you're now logged in to your Raspberry Pi and everything's working as expected.</li> </ol> </li> <li>Update the operating system that you installed on the microSD card. You used Raspberry Pi Imager for downloading the operating system but it might not contain the latest patches, fixes, and upgrades. Pull these things in:<ol> <li>Open a terminal window. If you're logged in through your laptop, you're already in the terminal window. If you're using an external keyboard and mouse, move the mouse over the icons at the top left, locate the one labelled Terminal, and click it.</li> <li>To see if there are any updates to the operating system, run the following command: <code>sudo apt-get update</code>. The local cache of the Raspberry Pi is updated with the package information for the package repositories. You're shown a list of the these packages, and now it's up to you to upgrade them to their latest versions.</li> <li>Upgrade the software shown on the list by running the following command: <code>sudo apt-get upgrade</code>. When prompted for permission to proceed with the upgrade, answer in the affirmative. The actual updates for the installed software and the operating system are now downloaded and installed on your Raspberry Pi. </li> </ol> </li> <li>If you don't have an external mouse or keyboard, set up Raspberry Pi Connect so that you can control the Raspberry Pi through a laptop through the Raspberry Pi's desktop GUI itself. You're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal window: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in. </li> </ol> </li> <li>If you're not immediately proceeding to the next step (where you write the Python program), shut down the Raspberry Pi.<ol> <li>If you're using an external mouse, close the terminal window. Then click the Raspberry Pi icon near the top left and click Shutdown &gt; Shutdown. Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> <li>If you're logged in through your laptop, type the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> </li> </ol> <p>Now that your Raspberry Pi is ready to be used as a computer, you can proceed to creating the Python script that displays your photo collection.</p>"},{"location":"_includes/pi_4_attach_heatsink/","title":"Pi 4 attach heatsink","text":""},{"location":"_includes/pi_4_attach_heatsink/#fix-heat-sinks-to-raspberry","title":"Fix heat sinks to Raspberry","text":"<p>A heat sink is a metal square object that is attached to a Raspberry Pi board by means of thermal paste. It draws the heat away from the processor, the USB controller, and the ethernet controller. A chiming program running on a Raspberry Pi 4B should not heat the little computer too much, but it is safe practice to use heat sinks. </p> <p>The three small corrugated squares that you see at the bottom left of the image are heat sinks. In the Raspberry Pi world, these corrugations are known as fins.</p> <p> To see a larger image, click the image.</p> <p>You must attach heat sinks to the CPU chip, the USB chip, and the network chip of the Raspberry Pi board. The one that goes over the CPU chip is the largest one; the one to use on the ethernet board is the smallest one.</p> <ol> <li>Peel off the adhesive strip at the back of the heat sink, all the while taking care that you don't touch the sticky part that the strip was covering. The sticky part is the thermal paste that will hold the sink in place.</li> <li>Press the sink ever so slightly on to the chip on the Raspberry Pi board.</li> </ol> <p>I found this YouTube video to be helpful.</p> <p>After the heat sinks are in place, prepare your laptop for the Raspberry Pi setup.</p>"},{"location":"_includes/pi_4_install_os/","title":"Pi 4 install os","text":""},{"location":"_includes/pi_4_install_os/#install-an-operating-system-on-the-raspberry-pi","title":"Install an operating system on the Raspberry Pi","text":"<p>For this project, you install the operating system called {{ pios }} for the model called {{ pimodel }}.</p> <ol> <li>Insert the microSD card to the Raspberry Pi's board, plug in the power adapter to a wall socket, and insert the cable into the USB-C power slot of the Raspberry Pi. If you're going to use an external keyboard and mouse, insert the USB receivers for these devices into the USB ports of the Raspberry Pi.</li> <li>Turn on the power switch of the wall socket. The light on the Raspberry Pi board should glow green, and the display screen should first show a rectangle of rainbow colours, and then finally show you the Raspberry Pi desktop screen.</li> <li>If you don't have an external keyboard and mouse, log in to the Raspberry Pi from your laptop:<ol> <li>Find the IP address of your nework gateway. To do so, on your laptop, open the command prompt, and type <code>ipconfig</code>. Then, note down the value that's displayed as Default Gateway.</li> <li>Start Angry IP Scanner. For the first box in the IP Range field, specify the value of the default gateway that you noted down in the previous step. For the second field, specify a number that's about 15-20 stops away. For example, if your default gateway is <code>192.168.4.1</code>, specify the end range to be something around <code>192.168.4.15</code>, so that the scan doesn't take too long. (The assumption here is that you don't already have more than 15-20 devices connected to your network!) Click Start and wait for the scan to be over. Then, in the Hostname column, look for the name of your Raspberry Pi. This is the name that you specified as the hostname in the OS Customisation settings while downloading the operating system on the microSD card. When you've spotted this hostname, look for the entry in the IP column. You need this value in the next step.</li> <li>On your laptop, start PuTTY and enter the IP address of your Raspberry Pi. This is the value that you noted down in your previous step. Click Open. When prompted for login credentials, enter the user name and password that you specified in the OS Customisation settings while downloading the operating system on the microSD card. You should now see a prompt like this: <code>&lt;hostname&gt;@&lt;username&gt;:~ $</code>. For example, if your hostname is <code>delphi</code> and user name is <code>oracle</code>, you'll see <code>delphi@oracle:~ $</code>It means you're now logged in to your Raspberry Pi and everything's working as expected.</li> </ol> </li> <li>Update the operating system that you installed on the microSD card. You used Raspberry Pi Imager for downloading the operating system but it might not contain the latest patches, fixes, and upgrades. Pull these things in:<ol> <li>Open a terminal window. If you're logged in through your laptop, you're already in the terminal window. If you're using an external keyboard and mouse, move the mouse over the icons at the top left, locate the one labelled Terminal, and click it.</li> <li>To see if there are any updates to the operating system, run the following command: <code>sudo apt-get update</code>. The local cache of the Raspberry Pi is updated with the package information for the package repositories. You're shown a list of the these packages, and now it's up to you to upgrade them to their latest versions.</li> <li>Upgrade the software shown on the list by running the following command: <code>sudo apt-get upgrade</code>. When prompted for permission to proceed with the upgrade, answer in the affirmative. The actual updates for the installed software and the operating system are now downloaded and installed on your Raspberry Pi. </li> </ol> </li> <li>If you don't have an external mouse or keyboard, set up Raspberry Pi Connect so that you can control the Raspberry Pi through a laptop through the Raspberry Pi's desktop GUI itself. You're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal window: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in. </li> </ol> </li> <li>If you're not immediately proceeding to the next step (where you write the Python program), shut down the Raspberry Pi.<ol> <li>If you're using an external mouse, close the terminal window. Then click the Raspberry Pi icon near the top left and click Shutdown &gt; Shutdown. Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> <li>If you're logged in through your laptop, type the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> </li> </ol> <p>Now that your Raspberry Pi is ready to be used as a computer, you can proceed to creating the clock chimes.</p>"},{"location":"_includes/pi_zero_attach_camera3/","title":"Pi zero attach camera3","text":""},{"location":"_includes/pi_zero_attach_camera3/#attach-camera-module-3-to-raspberry-pi-zero-w","title":"Attach Camera Module 3 to Raspberry Pi Zero W","text":"<p>The 12-megapixel Camera Module 3 is the latest official camera module. </p> <p> To see a larger image, click the image.</p> <p>When you buy the camera module, you get two connector cables:</p> <ul> <li>A white one, which is a 40-pin-to-40-pin cable and made for the Raspberry Pi 3 and Raspberry Pi 4 models.</li> <li>A golden one, which is a 40-pin-to-22-pin cable and made for the Raspberry Pi 5 and Raspberry Pi Zero models.</li> </ul> <p>In the image, you also see a shorter golden cable. I bought this separately; it's also a 40-pin-to-22-pin cable but shorter.</p> <p>For this project, you must attach the camera module to the Raspberry Pi with the golden cable.</p> <ol> <li>Turn the camera module upside down, with the lens facing down. You see a metal clip. Loosen the clip by pulling down the two tiny clamps at the ends.</li> <li>Insert the broad end of the golden cable into this clip, taking care that the metal connectors are facing down (that is, towards the lens side). </li> <li>Push the clamps down, so that the clip sits firmly back in its place.</li> <li>On the Raspberry Pi, pull out the camera clip. It's located near the power port.</li> <li>Insert the narrower end of the cable, with the metal connectors facing the bottom side of the Raspberry Pi. Push the clamps down firmly. I took the help of this YouTube video that shows which clips to pull, push, and connect to.</li> <li> <p>Verify that the camera is working as expected:</p> <ol> <li>Switch on the Raspberry Pi.</li> <li>Open a terminal window and run the following command: <code>libcamera-jpeg -n -o test.jpg</code>. You should see several messages being written to the terminal, ending with a message saying that a picture was taken. This means that the camera module was detected and is working fine.</li> </ol> <p></p> </li> <li> <p>If you don't see a success message on the terminal, verify that the camera pins are firmly in place. Then, try to use the terminal messages to troubleshoot. An AI agent such as ChatGPT can help.</p> </li> <li>If you're not immediately proceeding to the next step, shut down the Raspberry Pi by typing the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> <p>Now that the camera is in place, write the bash code for the surveillance setup.</p> <p>Because you're logged in through the terminal, you wouldn't be able to \"see\" the picture that you captured and saved as <code>test.jpg</code>. To see the image file, use the graphical interface of the Raspberry Pi computer itself and open the picture through its file manager. Here are the steps:</p> <ol> <li>Switch on Raspberry Pi.</li> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, you should see your Raspberry Pi. If you don't, wait for a few minutes and refresh the page.  Then, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should now see the Raspberry Pi desktop in your laptop browser.</li> <li>Open File Manager. It's one of the icons near the top where you see the Raspberry Pi icon.      </li> <li>In File Manager, go to <code>home/&lt;your user name&gt;</code>. You should see a file called <code>test.jpg</code>. To view the file, double-click it.</li> <li>When done, and if you're not immediately proceeding to the next step, shut down the Raspberry Pi by typing the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol>"},{"location":"_includes/pi_zero_install_os/","title":"Pi zero install os","text":""},{"location":"_includes/pi_zero_install_os/#install-the-operating-system","title":"Install the operating system","text":"<p>For this project, you install the operating system called {{ pios }} for the model called {{ pimodel }}.</p> <ol> <li>On the Raspberry Pi, locate the microSD card slot (it's midway between the mini-HDMI port and the header pins) and insert the microSD card into the slot.</li> <li>Plug in the Raspberry Pi power adapter to a wall socket, and insert the cable into the USB-C power slot of the Raspberry Pi. Turn on the power switch of the wall socket. The light on the Raspberry Pi board should glow green.</li> <li>Log in to the Raspberry Pi from your laptop:<ol> <li>Find the IP address of your nework gateway. To do so, on your laptop, open the command prompt, and type <code>ipconfig</code>. Then, note down the value that's displayed as Default Gateway.</li> <li>Start Angry IP Scanner. For the first box in the IP Range field, specify the value of the default gateway that you noted down in the previous step. For the second field, specify a number that's about 15-20 stops away. For example, if your default gateway is <code>192.168.4.1</code>, specify the end range to be something around <code>192.168.4.15</code>, so that the scan doesn't take too long. (The assumption here is that you don't already have more than 15 devices connected to your network!) Click Start and wait for the scan to be over. Then, in the Hostname column, look for the name of your Raspberry Pi. This is the name that you specified as the hostname in the OS Customisation settings while downloading the operating system on the microSD card. When you've spotted this hostname, look for the entry in the IP column. You need this value in the next step. </li> <li>Start PuTTY and enter the IP address of the Raspberry Pi. This is the value that you noted down in the previous step. Click Open. When prompted for login credentials, enter the user name and password that you specified in the OS Customisation settings while downloading the operating system on the microSD card. You should now see a prompt like this: <code>&lt;hostname&gt;@&lt;username&gt;:~ $</code>. For example, if your hostname is <code>delphi</code> and user name is <code>oracle</code>, you'll see <code>delphi@oracle:~ $</code>. It means you're now logged in to your Raspberry Pi and everything's working as expected.</li> </ol> </li> <li>Update the operating system that you installed on the microSD card. You used Raspberry Pi Imager for downloading the operating system but it might not contain the latest patches, fixes, and upgrades. Pull these things in.<ol> <li>To see if there are any updates to the operating system, run the following command: <code>sudo apt-get update</code>. The local cache of the Raspberry Pi is updated with the package information for the package repositories. You're shown a list of the these packages, and now it's up to you to upgrade them to their latest versions.</li> <li>Upgrade the software shown on the list by running the following command: <code>sudo apt-get upgrade</code>. When prompted for permission to proceed with the upgrade, answer in the affirmative. The actual updates for the installed software and the operating system are now downloaded and installed on your Raspberry Pi. </li> </ol> </li> <li>Set up Raspberry Pi Connect so that you can control the Raspberry Pi through a browser by using the Raspberry Pi's desktop GUI itself. At the moment, you're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal of the Raspberry Pi: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal of the Raspberry Pi: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in. </li> </ol> </li> <li>Shut down the Raspberry Pi by typing the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> <p>Now that your Raspberry Pi is ready to be used as a computer, you can proceed to attaching the camera module to it.</p>"},{"location":"_includes/python_clock_chime/","title":"Python clock chime","text":""},{"location":"_includes/python_clock_chime/#write-the-python-code-for-playing-the-clock-chimes","title":"Write the Python code for playing the clock chimes","text":"<p>For this clock-chiming project, the job of chiming on the hour and half-hour will be done by a Python program.</p> <p>The operating system that you installed on the Raspberry Pi already includes Python, as well as an integrated development environment (IDE) that makes it easier for you to write, run, and edit Python programs. This IDE is the Thonny IDE. You'll use Thonny to write the Python program.</p> <ol> <li>Plug in the speaker to the Raspberry Pi, and switch both of them on.</li> <li>If you don't have an external keyboard or mouse, log in remotely to your Raspberry Pi by using Connect:<ol> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should then see the Raspberry Pi desktop in your laptop browser window.</li> </ol> </li> <li>Install any patches, fixes, and upgrades that might have been made to the operating system by opening the Raspberry Pi terminal window (the console icon near the top left) and running the following two commands one after the other:<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt-get upgrade</code></li> </ul> </li> <li>Open Thonny by clicking the Raspberry Pi icon near the top left, and then clicking Programming &gt; Thonny.</li> <li>Create a virtual environment for your project. A virtual environment is like a boxed enclosure that contains all the Python libraries and packages that are needed for your code to run. Click Tools &gt; Options, and then click Interpreter. Make sure that the interpreter is <code>Local Python 3</code>. Then, click New virtual environment and follow the onscreen guidance to create an empty folder and designate it as the place where your project will live. When everything's done, click OK.</li> <li>Open a new file by clicking File &gt; New. Copy into it the code from The code section of this page.</li> <li>In the same virtual environment, at the same location as the <code>.py</code> file, paste a sound file containing the music you want to be played as the chimes. This sound file should be a <code>.wav</code> file because the <code>pygame</code> library can play only <code>.wav</code> files. For this project, I downloaded a royalty-free sound file that had peeling church bells, and then edited the file in to separate out a 2-second clip of a dinging sound.</li> <li>Install a Python package called <code>pygame</code> in the virtual environment. To do so, click Tools &gt; Manage packages, search for <code>pygame</code>, and click Install.</li> <li>Edit line 7 of the Python code to make sure that the file name is correct. For example, if your sound file is called <code>dingdong.wav</code>, line 7 should be <code>sound_file = 'dingdong.wav'</code>.</li> <li>Save the file, and click the Run icon. Wait for the half hour or the hour. You should be able to hear the chimes.</li> </ol>    Your browser does not support the video tag."},{"location":"_includes/python_clock_chime/#the-code","title":"The code","text":"<p><pre><code>import time\nfrom datetime import datetime\nimport pygame\n\n# Initialize pygame mixer\npygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)\nsound_file = 'ding.wav'\nchime_sound = pygame.mixer.Sound(sound_file)\n\ndef play_chime(times):\n    \"\"\"Play the chime the specified number of times.\"\"\"\n    for _ in range(times):\n        chime_sound.play()\n        time.sleep(2)  # A 2-second delay between chimes\n\ntry:\n    print('Chiming on the hour and half-hour. Press Ctrl+C to stop.')\n    while True:\n        now = datetime.now()\n        current_minute = now.minute\n        current_second = now.second\n\n        if current_minute == 30:\n            # Chime once for the half-hour\n            print('Chiming once for the half-hour.')\n            play_chime(1)\n            # Sleep until the top of the next hour\n            sleep_time = (60 - current_minute) * 60 - current_second\n            time.sleep(sleep_time)\n        elif current_minute == 0:\n            # Chime the number of times equal to the hour\n            chime_count = now.hour % 12 or 12  # Use 12 for midnight and noon\n            print(f'Chiming {chime_count} times for the hour {now.hour}.')\n            play_chime(chime_count)\n            # Sleep until the half-hour\n            sleep_time = 30 * 60 - current_second\n            time.sleep(sleep_time)\n        else:\n            # Determine whether to sleep until the half-hour or the hour\n            if current_minute &lt; 30:\n                sleep_time = (30 - current_minute) * 60 - current_second\n            else:\n                sleep_time = (60 - current_minute) * 60 - current_second\n            time.sleep(sleep_time)\n\nexcept KeyboardInterrupt:\n    print('\\nStopped chiming.')\n</code></pre> You can also download the raw Python file.</p> <p>Notice the first three lines of the code.</p> <pre><code>import time\nfrom datetime import datetime\nimport pygame\n</code></pre> <p>This is where you import the libraries and packages that are needed for this project. A Python library is a collection of programs that do a specific task, and can be called in your program by their name. Libraries make it easy to do things that would've otherwise needed you to write out, manually, the several lines of code needed to do that thing. For example, assume you need to count the number of words in a sentence. The manual (non-library) way of doing so would be to write something like this:</p> <pre><code>sentence = 'Beside the lake, beneath the trees, fluttering and dancing'\nword_counts = {}\nwords = sentence.split()  # Split the sentence into words\nfor word in words:\n    word = word.lower().strip(\".,!?\")  # Remove punctuation\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>Now, imagine doing the same thing with a library called <code>collections</code>, which contains code to do the heavy lifting. If you were to use this library, your code would look something like this, where you use a class called <code>Counter</code> to do the counting:</p> <pre><code>from collections import Counter\n\n# Count word occurrences using a library\nsentence = 'There was a time when meadow, grove, and stream, and every common sight to me did seem apparelled in celestial light.'\nwords = sentence.lower().split()\nnormalized_words = [word.strip(\".,!?\") for word in words]\nword_counts = Counter(normalized_words)\n\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>With libraries, you can write your programs with fewer lines of code, while using universal methods that can be recognised by any other Python programmer more easily than if they had to read non-library code.</p> <p>Some libraries are included by default in every Python installation. The libraries called <code>time</code> and <code>datetime</code>, which are imported in the first two lines, are such libraries. Some other libraries are ones that you manually install in the virtual environment of your project. The <code>pygame</code> library is one such library. It is a library for handling multimedia files like the sound file you use in this project.</p> <p>Take a look at this part of the code:</p> <pre><code>time.sleep(2)  # A 2-second delay between chimes\n</code></pre> <p>This bit specifies a 2-second delay when the chimes are going to be repeated for the number of hours. For example, if it is 4 o'clock, the playing is repeated four times, with a 2-second delay between the repetitions.</p> <p>Look at how <code>sleep_time</code> is calculated. It takes into account the seconds that have elapsed while the sound was playing; therefore, this <code>sleep_time</code> is calculated twice, once on the hour and once on the half-hour.</p> <pre><code>sleep_time = (60 - current_minute) * 60 - current_second\n\n...\n\nsleep_time = 30 * 60 - current_second\n</code></pre> <p>Take a look at this bit, which controls the number of times the chime is played:</p> <pre><code>play_chime(1)\n\n...\n\nplay_chime(chime_count)\n</code></pre> <p><code>chime_count</code> is calculated according to the current hour, as follows: <code>chime_count = now.hour % 12 or 12</code>. The reason for using a modulus operation rather than a substraction operation (like <code>chime_count = now.hour - 12</code>) is explained in the following table.</p> <code>now.hour</code> Modulus (<code>now.hour % 12</code>) Substraction (<code>now.hour - 12</code>) Notes 13 1 1 Both methods return the correct hour. 14 2 2 Both methods return the correct hour. 23 11 11 Both methods return the correct hour. 0 (midnight) 0 - 12 Incorrect. Solved by using <code>or 12</code> in the modulus operation. 12 (noon) 0 0 Incorrect. Solved by using <code>or 12</code> in the modulus operation. <p>Notice the <code>or</code> operater in <code>chime_count = now.hour % 12 or 12</code>. This code sets the value of the <code>chime_count</code> variable to the modulus value, but if the modulus is zero, sets the <code>chime_count</code> value to 12.</p> <p>Now, see this bit near the start of the code:</p> <pre><code>pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)\n</code></pre> <p>This code initialises the <code>pygame</code> module with the following parameters: - <code>frequency</code>, which is set to match my sound file's sample rate. To find the sample rate of your sound file, run the following command from the Raspberry Pi terminal: <code>file &lt;filename.wav&gt;</code>, where <code>filename.wav</code> must be replaced by the name of your sound file. You should get an output that's something like this: <code>RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz</code> - <code>size</code>, which is the bit-depth of the sound file. In my case, because the format is <code>PCM</code>, a negative sign (<code>-16</code>) is used, which is standard for PCM data.  - <code>channels</code>, which is set to <code>2</code> because my audio device is a dual-channel speaker. - <code>buffer</code>, increased from the default of <code>2048</code> to remove any stuttering.</p> <p>You can also do a simpler initialisation, without specifying the parameters, like this: <code>pygame.mixer.init()</code>.  But sometimes, doing so might lead to the sound file seeming to stutter on playback due to buffering issues.</p>"},{"location":"_includes/python_clock_chime/#troubleshooting-the-code","title":"Troubleshooting the code","text":"<p>1.  <code>pygame</code> not found</p> <p>If <code>pygame</code> does not show up in the search results when you try to install it through Tools &gt; Manage packages:</p> <ol> <li>Close Thonny.</li> <li>Open the terminal and run the following two commands one after the other:<ul> <li><code>sudo apt update</code></li> <li><code>sudo apt install python3-full</code> </li> </ul> </li> <li>Go to the directory that contains your project files, and look for a file called <code>pyvenv.cfg</code>. Right-click the file, click Text editor, and make sure the value of <code>include-system-site-packages</code> is set to <code>true</code>. Save the file, and close it.</li> <li>Reopen Thonny, and click Tools &gt; Manage packages. </li> </ol> <p>You should now be able to see <code>pygame</code> in the list of installed packages.</p> <p>2.  Stuttering playback</p> <p>If your sound file plays perfectly on your laptop but seems to be stuttering on the Raspberry Pi computer, the problem might lie with buffering. Increase the buffer size to <code>8192</code> or higher when initialising the <code>pygame</code> library at line 6.</p>"},{"location":"_includes/python_library/","title":"Python library","text":"<p>A Python library is a collection of programs that do a specific task, and can be called in your program by their name. Libraries make it easy to do things that would've otherwise needed you to write out, manually, the several lines of code needed to do that thing. For example, assume you need to count the number of words in a sentence. The manual (non-library) way of doing so would be to write something like this:</p> <pre><code>sentence = 'Beside the lake, beneath the trees, fluttering and dancing'\nword_counts = {}\nwords = sentence.split()  # Split the sentence into words\nfor word in words:\n    word = word.lower().strip(\".,!?\")  # Remove punctuation\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>Now, imagine doing the same thing with a library called <code>collections</code>, which contains code to do the heavy lifting. If you were to use this library, your code would look something like this, where you use a class called <code>Counter</code> to do the counting:</p> <pre><code>from collections import Counter\n\n# Count word occurrences using a library\nsentence = 'There was a time when meadow, grove, and stream, and every common sight to me did seem apparelled in celestial light.'\nwords = sentence.lower().split()\nnormalized_words = [word.strip(\".,!?\") for word in words]\nword_counts = Counter(normalized_words)\n\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>With libraries, you can write your programs with fewer lines of code, while using universal methods that can be recognised by any other Python programmer more easily than if they had to read non-library code.</p>"},{"location":"_includes/python_photo_frame/","title":"Python photo frame","text":""},{"location":"_includes/python_photo_frame/#write-the-python-code-for-displaying-the-photos","title":"Write the Python code for displaying the photos","text":"<p>A digital photo frame reads photo files from a storage device, and displays them on the screen for a specified time. For the photo frame that you're building, this job will be done by a Python program.</p> <p>The operating system that you installed on the Raspberry Pi already includes Python, as well as an integrated development environment (IDE) that makes it easier for you to write, run, and edit Python programs. This IDE is the Thonny IDE. You'll use Thonny to write the photo frame program.</p> <ol> <li>Plug in the USB drive containing your photos to the Raspberry Pi, and switch it on.</li> <li>If you don't have an external keyboard or mouse, log in remotely to your Raspberry Pi by using Connect:<ol> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should then see the Raspberry Pi desktop in your laptop browser window.</li> </ol> </li> <li>Install any patches, fixes, and upgrades that might have been made to the operating system by opening the Raspberry Pi terminal window (the console icon near the top left) and running the following two commands one after the other:<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt-get upgrade</code></li> </ul> </li> <li>Open Thonny by clicking the Raspberry Pi icon near the top left, and then clicking Programming &gt; Thonny.</li> <li>Create a virtual environment for your project. A virtual environment is like a boxed enclosure that contains all the Python libraries and packages that are needed for your code to run. Click Tools &gt; Options, and then click Interpreter. Make sure that the interpreter is <code>Local Python 3</code>. Then, click New virtual environment and follow the onscreen guidance to create an empty folder and designate it as the place where your project will live. When everything's done, click OK.</li> <li>Open a new file by clicking File &gt; New. Copy into it the code from The code section of this page. Then, edit line 20 to change <code>usb_dir = '/media/pi/'</code> to <code>usb_dir = '/media/&lt;yourPiUserName&gt;/'</code>. For example, if the user name that you specified when setting up the Raspberry Pi was <code>oracle</code>, line 20 in the code should be <code>usb_dir = '/media/oracle/'</code>.</li> <li>Install a Python package called <code>Pillow</code> in the virtual environment. To do so, click Tools &gt; Manage packages, search for <code>Pillow</code>, and click Install.</li> <li>Save the file, and click the Run icon. You should see your photos being picked up and displayed one after the other.</li> </ol>    Your browser does not support the video tag.  <p>Your photo frame is now ready. You can leave it as is now, or you might choose to refine it.</p>"},{"location":"_includes/python_photo_frame/#the-code","title":"The code","text":"<pre><code>import os\nimport time\nimport tkinter as tk\nfrom PIL import Image, ImageTk\n\n# Function to get a list of image files from a directory and its subdirectories\ndef get_image_files(directory):\n    image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif'}\n    image_files = []\n    for root, _, files in os.walk(directory):\n        for file in files:\n            if file.lower().endswith(tuple(image_extensions)):\n                image_files.append(os.path.join(root, file))\n    return image_files\n\n# Main function to run the digital photo frame\ndef digital_photo_frame():\n    # Directories to scan for images\n    local_dir = os.getcwd()  # Current working directory\n    usb_dir = '/media/pi/'  # The USB mount path in the Raspberry Pi\n    # Collect all image files\n    images = get_image_files(local_dir) + get_image_files(usb_dir)\n    if not images:\n        print(\"Couldn't find any image files in the specified directories.\")\n        return\n    # Create a Tkinter window\n    root = tk.Tk()\n    root.title('Raspberry Pi Photo Frame') # The title doesn't matter; it won't be displayed\n    # Fullscreen settings (optional)\n    root.attributes('-fullscreen', True)\n    root.bind(\"&lt;Escape&gt;\", lambda e: root.destroy())  # Exit fullscreen with the Esc key\n    # Label to display the image\n    label = tk.Label(root)\n    label.pack(expand=True, fill=tk.BOTH)\n    # Function to update the displayed image\n    def update_image(index):\n        img_path = images[index]\n        img = Image.open(img_path)\n        img = img.resize((root.winfo_screenwidth(), root.winfo_screenheight()), Image.Resampling.LANCZOS)\n        photo = ImageTk.PhotoImage(img)\n        label.config(image=photo)\n        label.image = photo\n        root.after(10000, update_image, (index + 1) % len(images))  # Change the image every 10 seconds\n    # Start displaying the first image\n    update_image(0)\n    # Run the Tkinter event loop\n    root.mainloop()\n\n# Run the script\nif __name__ == \"__main__\":\n    digital_photo_frame()\n</code></pre> <p> You can also download the raw Python file.</p> <p>Notice the first four lines of the code.</p> <pre><code>import os\nimport time\nimport tkinter as tk\nfrom PIL import Image, ImageTk\n</code></pre> <p>This is where you import all the libraries and packages needed for this project. A Python library is a collection of programs that do a specific task, and can be called in your program by their name. Libraries make it easy to do things that would've otherwise needed you to write out, manually, the several lines of code needed to do that thing. For example, assume you need to count the number of words in a sentence. The manual (non-library) way of doing so would be to write something like this:</p> <pre><code>sentence = 'Beside the lake, beneath the trees, fluttering and dancing'\nword_counts = {}\nwords = sentence.split()  # Split the sentence into words\nfor word in words:\n    word = word.lower().strip(\".,!?\")  # Remove punctuation\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>Now, imagine doing the same thing with a library called <code>collections</code>, which contains code to do the heavy lifting. If you were to use this library, your code would look something like this, where you use a class called <code>Counter</code> to do the counting:</p> <pre><code>from collections import Counter\n\n# Count word occurrences using a library\nsentence = 'There was a time when meadow, grove, and stream, and every common sight to me did seem apparelled in celestial light.'\nwords = sentence.lower().split()\nnormalized_words = [word.strip(\".,!?\") for word in words]\nword_counts = Counter(normalized_words)\n\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>With libraries, you can write your programs with fewer lines of code, while using universal methods that can be recognised by any other Python programmer more easily than if they had to read non-library code.</p> <p>Some libraries are included by default in every Python installation. The libraries called <code>os</code>, <code>time</code>, and <code>tkinter</code>, called in the first three lines, are such libraries. Some other libraries are ones that you manually install in the virtual environment of your project. The <code>pillow</code> library, called here as <code>PIL</code>, is one such library. It is a library for handling images.</p> <p>Take a look at this part of the code:</p> <pre><code>image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif'}\n</code></pre> <p>All the possible photo extensions are listed here, but if you think any is missing, go ahead and add it here. If any of your photos use extensions spelt in uppercase letters (for example, <code>.JPEG</code> or <code>.PNG</code>), it's a good idea to add them to this list too.</p> <p>See this bit of the code:</p> <pre><code># Fullscreen settings (optional)\nroot.attributes('-fullscreen', True)\nroot.bind(\"&lt;Escape&gt;\", lambda e: root.destroy())  # Exit fullscreen with the Esc key\n</code></pre> <p>You would've noticed that the display takes up the entire screen. Now, what if you need to stop the program from running? None of the Raspberry Pi controls are displayed anywhere. To take care of this eventuality, the <code>Esc</code> key of the keyboard has been bound to the action to stop the program midway.</p> <p>Take a look at this bit, which controls the time for which a photo is displayed:</p> <pre><code>root.after(10000, update_image, (index + 1) % len(images))  # Change the image every 10 seconds\n</code></pre> <p>The number <code>10000</code> is in milliseconds. It means, every photo is displayed for 10 seconds. You can change this value to whatever you want the time lag between photos to be.</p>"},{"location":"_includes/python_photo_frame/#troubleshooting-the-code","title":"Troubleshooting the code","text":"<p>If <code>Pillow</code> does not show up in the search results when you try to install it through Tools &gt; Manage packages:</p> <ol> <li>Close Thonny.</li> <li>Open the terminal and run the following two commands one after the other:<ul> <li><code>sudo apt update</code></li> <li><code>sudo apt install python3-full</code> </li> </ul> </li> <li>Go to the directory that contains your project files, and look for a file called <code>pyvenv.cfg</code>. Right-click the file, click Text editor, and make sure the value of <code>include-system-site-packages</code> is set to <code>true</code>. Save the file, and close it.</li> <li>Reopen Thonny, and click Tools &gt; Manage packages. </li> </ol> <p>You should now be able to see <code>Pillow</code> in the list of installed packages.</p>"},{"location":"_includes/security_camera_refine/","title":"Security camera refine","text":""},{"location":"_includes/security_camera_refine/#refine-the-project","title":"Refine the project","text":"<p>Now that your surveillance camera is working, consider the following enhancements.</p> <ul> <li>Never lose a frame</li> <li>Keep cool</li> <li>Stop elegantly</li> <li>Back up</li> </ul>"},{"location":"_includes/security_camera_refine/#never-lose-a-frame","title":"Never lose a frame","text":"<p>You might have noticed that the videos have timestamps like this:</p> <pre><code>ve_20250420_122534.h264\nve_20250420_122644.h264\nve_20250420_122753.h264\nve_20250420_122903.h264\n</code></pre> <p>You're losing about 9 to 10 seconds between each video.</p> <pre><code>ve_20250420_122534  \u2192 12:25:34\nve_20250420_122644  \u2192 12:26:44  \u2192 +1 min 10 sec\nve_20250420_122753  \u2192 12:27:53  \u2192 +1 min 9 sec\nve_20250420_122903  \u2192 12:29:03  \u2192 +1 min 10 sec\n</code></pre> <p>Even though you're capturing 1-minute videos, the next one doesn't start immediately at the end of the previous one. Rather, there's a small delay while one <code>libcamera-vid</code> command finishes and the next one starts. But a lot can happen in 10 seconds! To not lose any frames, use a background recording, by tweaking the bash script a bit.</p> <pre><code>#!/bin/bash\nSAVE_PATH=\"/home/oracle/Videos\"\nmkdir -p \"$SAVE_PATH\"\n\nwhile true; do\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout 60000 -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\" &amp;\n  wait\ndone\n</code></pre> <p>Notice the following difference:</p> <pre><code>  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout 60000 -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\" &amp;\n  wait\n</code></pre> <p>Here:</p> <ul> <li><code>----timeout 60000</code>: This sets how long the video recording lasts in milliseconds. 60000 ms means 60 seconds (1 minute). You can change this to however long you want each video segment to be.</li> <li><code>&amp;</code>: This little symbol at the end means the command should be run in the background, so that the script doesn't pause while the video is recording; rather, it moves on and prepares for the next loop.</li> <li><code>wait</code>: This pauses the script for the timeout duration until tha background command finishes. When the video recording ends, the script continues.</li> </ul> <p>This change slightly reduces how long it takes for the next loop to begin. It is by no means seamless, but it at least reduces the 10s delay to about 2s to 3s.</p>"},{"location":"_includes/security_camera_refine/#keep-cool","title":"Keep cool","text":"<p>Security cameras, like Lakshman, don't sleep. This means that the Raspberry Pi computer will be running continuously, days on end. If you live in an area like mine, where summer temperatures can cross 50 degrees centigrade, you'd like to ensure that the camera hanging outside doesn't get too hot (Lakshman was known to be extremely hot-tempered, though). Consider using an aluminium heat sink made specially for Raspberry Pi Zero W.</p>"},{"location":"_includes/security_camera_refine/#stop-elegantly","title":"Stop elegantly","text":"<p>To stop the bash command that you started with <code>./simplevideo.sh</code>, you press Ctrl + C in the terminal window. Oftentimes, you might see that the script automatically start recording again. This happens because of the following line in your script:</p> <pre><code>libcamera-vid ... &amp;\nwait\n</code></pre> <p><code>&amp;</code> puts <code>libcamera-vid</code> in the background. <code>wait</code> then pauses until that background process finishes. <code>while true</code> restarts the loop. Endlessly. When you press Ctrl + C, your action sends an interrupt signal (called <code>SIGINT</code> in the Debian world) to the foreground process (the <code>wait</code> command). But because <code>libcamera-vid</code> is running in the background, it may not receive that signal and, therefore, the loop continues and restarts the background recording.</p> <p>To handle this situation gracefully, set a trap to catch the interrupt signal in the bash script. The modified script should look like this:</p> <pre><code>#!/bin/bash\nSAVE_PATH=\"/home/dwarpal/Videos\"\nmkdir -p \"$SAVE_PATH\"\n\n# Trap Ctrl+C (SIGINT)\ntrap \"echo 'Stopping...'; kill 0; exit\" SIGINT\n\nwhile true; do\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout 60000 -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\" &amp;\n  wait\ndone\n</code></pre> <p>Notice the new bit, which is on lines 4 and 5. <code>trap ... SIGINT</code> listens for Ctrl + C. <code>kill 0</code> sends a signal to all processes in the current script group so that it kills the background <code>libcamera-vid</code> and stops the loop. <code>exit</code> stops the script elegantly. <code>echo</code> prints a message on the terminal.</p>"},{"location":"_includes/security_camera_refine/#back-up","title":"Back up","text":"<p>Because this project is about surveillance, you wouldn't want to lose files before you've seen them. The Raspberry Pi Zero is a marvellous computer, but its limited resources means that you can't really connect a screen to it and keep viewing the video files without drawing upon too much of its resources. An alternative is to move the files to another computer and view them at leisure.</p> <ul> <li>Manually transfer the videos to a different computer</li> <li>Automatically upload the videos to a cloud storage</li> </ul>"},{"location":"_includes/security_camera_refine/#manual-transfer-to-another-computer","title":"Manual transfer to another computer","text":"<p>...still being written...</p>"},{"location":"_includes/security_camera_refine/#automatic-upload-to-a-cloud-storage","title":"Automatic upload to a cloud storage","text":"<p>Use the <code>rclone</code> package to point to your cloud storage, and then create a cronjob that automatically moves the files from Raspberry Pi to cloud storage at the specified time. This task has several steps.</p> <ol> <li>Install rclone on the laptop.</li> <li>Install rclone on Raspberry Pi.</li> <li>Connect rclone to your cloud storage.</li> <li>Write a bash script to upload videos to cloud storage.</li> <li>Create a cron job to automatically run this bash script.</li> </ol> <p>The details are here:</p> <ol> <li>Switch on your laptop and install <code>rclone</code> on it:<ol> <li>Go to the rclone downloads page and download the <code>.zip</code> file for your Windows laptop.</li> <li>Extract the content to any folder, for example, <code>C:/rclone</code>. Make a note of this folder because you'll need it in a subsequent step.</li> </ol> </li> <li>Switch on your Raspberry Pi, log into it by using Connect on your laptop, and then open a terminal window on Raspberry and install <code>rclone</code> by running the following command commands one after the other:<ol> <li><code>sudo apt update</code>: To find all patches and fixes since the last time that the Raspberry Pi was updated</li> <li><code>sudo apt upgrade -y</code>: To download and install the packs identified in the previous step.</li> <li><code>sudo apt install rclone -y</code>: To install <code>rclone</code>.</li> </ol> </li> <li> <p>Connect <code>rclone</code> to your cloud store:</p> <ol> <li>Start the configuration process by running the following command: <code>rclone config</code>.</li> <li>At the first prompt, type <code>n</code> (for <code>New remote</code>). </li> <li>Specify a name for the connection, for example, <code>gdrive</code>. Make a note of this name because you'll need it soon in a subsequent step.</li> <li>Scroll through the long list that you're presented with and identify the number for the cloud storage service. Then, type the number.</li> <li>Leave the fields for <code>Client ID</code> and <code>Secret</code> blank by entering nothing and pressing Enter.</li> <li>For the scope of access, enter <code>1</code> for full access.</li> <li>Leave the fields for <code>Root Folder ID</code> and <code>Service Account File</code> blank by entering nothing and pressing Enter.</li> <li>Say <code>No</code> to advanced config. Say <code>No</code> to auto-config as well. You'll be given a command for authorising <code>rclone</code>, for example, <code>rclone authorize \"drive\" \"abCdE12wfGH3IjKlmNOpQr4\"</code>. Copy that command.</li> <li> <p>Return to your laptop, open the command prompt, and go to the folder where you extracted <code>rclone</code> to. Paste the command that you copied from Raspberry Pi. You're given a verification code.   </p> </li> <li> <p>Copy the verification code, return to the Raspberry Pi terminal, and paste it. You see a confirmation message. If asked whether to configure the setup as a shared drive, respond in the negative. Enter <code>y</code>, and then exit the configuration setup by entering <code>q</code>.</p> </li> <li>Test the connection by running the following commands one after the other. You should see a folder called <code>rclonetest</code> in your cloud storage with a file called <code>testfile.txt</code> that has a single line saying <code>Testing rclone setup</code>. Before running the commands, replace <code>gdrive</code> with the name of your cloud storage. You made a note of this name in a previous step.</li> <li><code>echo \"Testing rclone setup\" &gt; testfile.txt</code></li> <li><code>rclone copy testfile.txt gdrive:rclonetest</code></li> <li>... still writing ...</li> </ol> </li> </ol>"},{"location":"_includes/set_up_laptop/","title":"Set up laptop","text":""},{"location":"_includes/set_up_laptop/#prepare-your-laptop-for-the-raspberry-pi-installation","title":"Prepare your laptop for the Raspberry Pi installation","text":"<p>Before you can use your laptop to run a Raspberry Pi OS installation, make sure that the following software is available on it.</p> <ul> <li>Download SD Memory Card Formatter. Before you can load an operating system on your microSD card, you must format it. Use the formatter provided by the SD Association because this formatter is platform-agnostic. </li> <li>Download Raspberry Pi Imager. The good folks at Raspberry Org have created a wizard that can install an operating system on a microSD card and also, simultaneously, configure the operating system with the barest minimum parameters that are needed to get a Raspberry Pi computer up and running. This wizard is known as Raspberry Pi Imager. </li> <li>Download Angry IP Scanner. If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. To do so, you need the IP address of the Raspberry Pi. A network scanner can show you the IP addresses of all devices that are connected to your network. One such network scanner is Angry IP Scanner, so download it.</li> <li>Download PuTTY.  If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. One of the ways to do so is by using a secure shell (SSH) connection. PuTTY is an SSH client through which you can interactively run a command-line session on your Raspberry Pi. </li> <li>(Optional) Download WinSCP. If you need to transfer files to and from the Raspberry Pi computer, you need a secure file-transfer client. WinSCP is one such client. </li> </ul> <p>When you're done, you should have the following software on your laptop. </p> <p></p> <p>You are now ready to install an operating system on your Raspberry Pi.</p>"},{"location":"_includes/thonny_install_packages/","title":"Thonny install packages","text":"<ol> <li>Close Thonny.</li> <li>Open the terminal and run the following two commands one after the other:<ul> <li><code>sudo apt update</code></li> <li><code>sudo apt install python3-full</code> </li> </ul> </li> <li>Go to the directory that contains your project files, and look for a file called <code>pyvenv.cfg</code>. Right-click the file, click Text editor, and make sure the value of <code>include-system-site-packages</code> is set to <code>true</code>. Save the file, and close it.</li> <li>Reopen Thonny, and click Tools &gt; Manage packages. </li> </ol>"},{"location":"_includes/thonny_venv/","title":"Thonny venv","text":"<ol> <li>Create a virtual environment for your project. A virtual environment is like a boxed enclosure that contains all the Python libraries and packages that are needed for your code to run. Click Tools &gt; Options, and then click Interpreter. Make sure that the interpreter is <code>Local Python 3</code>. Then, click New virtual environment and follow the onscreen guidance to create an empty folder and designate it as the place where your project will live. When everything's done, click OK.</li> </ol>"},{"location":"topics/clock_chimes_intro/","title":"Clock chimes","text":"<p>There was a time when meadow, grove, and stream, the earth, and every common sight, was apparelled in celestial light. It is not now as it hath been of yore. The things which I have seen I now can see no more. One such thing is a grandfather clock, that let out stately dings on the hour, every hour.</p>    Your browser does not support the video tag.  <p>This project uses a Raspberry Pi 4 computer and an external speaker to simulate the chimes of a grandfather clock. To make it all work, you must set up a headless Raspberry Pi computer, and write Python code on it. It doesn't matter if you don't know Python, because I'll provide the entire code for you to copy and use.</p>"},{"location":"topics/clock_chimes_intro/#materials","title":"Materials","text":"<p>For the chimes:</p> <ul> <li>A Raspberry Pi 4B computer. This little computer board will hold the code that makes the chimes ring out every half hour and hour. Strictly speaking, you don't need a Raspberry Pi 4B computer; an older model will work excellently too because this project doesn't need much computing power. But I was already using my Raspberry Pi 4B for something else, so I deployed this project on it. Any Raspberry Pi model that has a 3.5 mm audio port will work (see Note 1 later on this page).</li> <li>A speaker. For this project, I used a Honeywell soundbar, but you can use any speaker that has a 3.5 mm audio jack and is externally powered through a separate wall socket (see Note 2 later on this page).</li> <li>A Raspberry Pi official power adapter. Theoretically, any adapter with a USB-C cable that can plug into the Raspberry Pi should work fine. In practice, it's better to get the official power adapter because it's been tested to deliver the exact power that the Raspberry Pi needs.</li> <li>A microSD card. This tiny card will contain the operating system that your Raspberry Pi will run on.</li> <li>(Optional) Heat sinks. These are little metal blocks that draw the heat away from the chips on the Raspberry Pi board. A Python program for this project should not heat the Raspberry Pi too much, but it is safe practice to use heat sinks.</li> <li>(Optional) An external keyboard and a mouse. These two things are optional, because you can use your laptop keyboard and touchpad to issue commands to the Raspberry Pi computer.</li> <li>A sound file with clock chimes. This file must be in the <code>.wav</code> format.</li> <li>(Optional) A sound-editing program like Audacity. This software is needed only if you want to edit the sound file you'll use in this project.</li> </ul> <p>To set up the Raspberry Pi:</p> <ul> <li>A laptop (or desktop), with a microSD port. If your laptop does not have this port, you need a microSD card reader that you can plug into laptop. After the Raspberry Pi is set up and the photo frame is working, you'll no longer need the laptop.</li> <li>Administrator privileges on the laptop, so that you can download all the required software on it.</li> <li>An internet connection. After the set up is complete, this project does not need an internet connection.</li> </ul>"},{"location":"topics/clock_chimes_intro/#steps","title":"Steps","text":"<p>You make the Raspberry Pi ready by installing an operating system on it, and write a script to play the chimes. A step-by-step guide is at how to chime on the hour and the half hour.</p>"},{"location":"topics/clock_chimes_intro/#cost","title":"Cost","text":"<p>All figures are in Indian Rupees (INR), and inclusive of GST (goods and service tax).</p> Item Amount (INR) Raspberry Pi 4 8GB (see Note 1) 8,999.00 15.3W USB-C Power Supply - Official (For Raspberry Pi 4) 672.60 Amazon Basics 32GB MicroSDHC Memory Card with Adapter 369.00 Aluminium Heat Sink 35.40 Honeywell Moxie V500 10W Portable USB Wired Soundbar (see Note 2) 789.00 10,865.00 <p>Note 1: You can also use a Raspberry Pi 4 model with lesser RAM. One with 1GB, which is sufficient to run the chiming script, costs INR 3,599.00, which is almost 30% cheaper than the model used in this tutorial. You can use an older Raspberry Pi model too, so long as you can plug a 3.5 mm audio jack in it. Here are some options:</p> <ul> <li>Raspberry Pi Zero 2W (INR 1,569.00), with a USB2-to-audio-port coupler. Alternatively, use the mini-HDMI port to connect to a monitor that has inbuilt speakers.</li> <li>Raspberry Pi 3A (INR 2,559.00) or Raspberry Pi 3B (INR 3,598.00), which already have an audio port.</li> </ul> <p>Note 2: You can use any externally powered speaker that has a 3.5 mm audio jack.</p>"},{"location":"topics/clock_chimes_intro/#alternatives","title":"Alternatives","text":"<p>A battery-operated grandfather clock, like this one from Titan.</p>"},{"location":"topics/clock_chimes_intro/#motivation","title":"Motivation","text":"<p>The reason for this project was that I was missing the chimes of the wallclock that we had at my childhood home, and I had spare resources on the Raspberry Pi computer.</p>"},{"location":"topics/clock_chimes_steps/","title":"Make chimes on the hour and half hour","text":"<p>The steps to make the chimes are these:</p> <ol> <li>Attach the heat sinks to the Raspberry Pi board.</li> <li>Prepare your laptop.</li> <li>Download the Raspberry Pi operating system.</li> <li>Install the operating system.</li> <li>Write the Python code that makes the chimes.</li> </ol> <p> To see a larger image, click the image.</p>"},{"location":"topics/clock_chimes_steps/#fix-heat-sinks-to-raspberry","title":"Fix heat sinks to Raspberry","text":"<p>A heat sink is a metal square object that is attached to a Raspberry Pi board by means of thermal paste. It draws the heat away from the processor, the USB controller, and the ethernet controller. A chiming program running on a Raspberry Pi 4B should not heat the little computer too much, but it is safe practice to use heat sinks. </p> <p>The three small corrugated squares that you see at the bottom left of the image are heat sinks. In the Raspberry Pi world, these corrugations are known as fins.</p> <p> To see a larger image, click the image.</p> <p>You must attach heat sinks to the CPU chip, the USB chip, and the network chip of the Raspberry Pi board. The one that goes over the CPU chip is the largest one; the one to use on the ethernet board is the smallest one.</p> <ol> <li>Peel off the adhesive strip at the back of the heat sink, all the while taking care that you don't touch the sticky part that the strip was covering. The sticky part is the thermal paste that will hold the sink in place.</li> <li>Press the sink ever so slightly on to the chip on the Raspberry Pi board.</li> </ol> <p>I found this YouTube video to be helpful.</p> <p>After the heat sinks are in place, prepare your laptop for the Raspberry Pi setup.</p>"},{"location":"topics/clock_chimes_steps/#prepare-your-laptop-for-the-raspberry-pi-installation","title":"Prepare your laptop for the Raspberry Pi installation","text":"<p>Before you can use your laptop to run a Raspberry Pi OS installation, make sure that the following software is available on it.</p> <ul> <li>Download SD Memory Card Formatter. Before you can load an operating system on your microSD card, you must format it. Use the formatter provided by the SD Association because this formatter is platform-agnostic. </li> <li>Download Raspberry Pi Imager. The good folks at Raspberry Org have created a wizard that can install an operating system on a microSD card and also, simultaneously, configure the operating system with the barest minimum parameters that are needed to get a Raspberry Pi computer up and running. This wizard is known as Raspberry Pi Imager. </li> <li>Download Angry IP Scanner. If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. To do so, you need the IP address of the Raspberry Pi. A network scanner can show you the IP addresses of all devices that are connected to your network. One such network scanner is Angry IP Scanner, so download it.</li> <li>Download PuTTY.  If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. One of the ways to do so is by using a secure shell (SSH) connection. PuTTY is an SSH client through which you can interactively run a command-line session on your Raspberry Pi. </li> <li>(Optional) Download WinSCP. If you need to transfer files to and from the Raspberry Pi computer, you need a secure file-transfer client. WinSCP is one such client. </li> </ul> <p>When you're done, you should have the following software on your laptop. </p> <p></p> <p>You are now ready to install an operating system on your Raspberry Pi.</p>"},{"location":"topics/clock_chimes_steps/#download-the-operating-system","title":"Download the operating system","text":"<p>For this step, you need a microSD card and a card reader that can be plugged into your laptop.</p> <p>The operating system will be downloaded on to the microSD card, which will then be inserted into the microSD slot of the Raspberry Pi board, which will then be plugged into a power socket. That's what will get the little board up and running, and make it ready for the final steps of the project.</p> <ol> <li>Turn on your laptop. Make sure that it is connected to the internet.</li> <li>Plug the microSD card into your laptop, and format it by running SD Card Formatter. Use the Overwrite option to format; this option takes longer but ensures that everything on the SD card is wiped clean and the card formatted.</li> <li>On the laptop, run the Raspberry Pi Imager wizard and download Raspberry Pi's operating system to it. All Raspberry Pi computers run on  operating systems that are based on the open-source Debian operating system. This project uses Debian Bookworm with the Raspberry Pi Desktop. Begin the download process by selecting the model as Raspberry Pi 4 and the operating system as Raspberry Pi OS 64-bit (A port of Debian Bookworm with the Raspberry Pi Desktop).</li> <li>On the page for OS customisation, click Edit settings. These settings are used for configuring the operating system with your credentials and environment. If prompted for loading Wi-Fi credentials from your host computer, respond in the affirmative. Then, specify the values for at least the following parameters. It's also a good idea to note down these values for easy reference, because you'll need these values later:<ul> <li>On the General page:<ul> <li>hostname, which is a name you call your Raspberry Pi by. This is the name that'll be displayed when you search for your Raspberry Pi on the network later.</li> <li>username and password, which are the credentials to use when logging in to Raspberry Pi remotely. The user name that you specify here will have administrator privileges to your Raspberry Pi.</li> <li>Wireless LAN, which should be prepopulated because you already asked the Wi-Fi credentials to be loaded from the host computer.</li> <li>Locale settings, for your time zone, keyboard preferences, and other such locale-related things.</li> </ul> </li> <li>On the Services page, select the Enable SSH box and the option for password authentication. Later, when the project is up and running, you might choose to isolate your Raspberry Pi from the network, and if you decide to do that, you can turn SSH off, but for the time being, enable it because you might need it for troubleshooting purposes.</li> <li>On the Options page, select all the options.</li> </ul> </li> <li>Click Save and, when prompted for applying these settings, answer in the affirmative. Click Yes again, and then wait for the operating system to be copied on to the microSD card.</li> <li>When the process is complete, take the microSD card out of the laptop port.</li> </ol>"},{"location":"topics/clock_chimes_steps/#install-an-operating-system-on-the-raspberry-pi","title":"Install an operating system on the Raspberry Pi","text":"<p>For this project, you install the operating system called Raspberry Pi OS 64-bit (A port of Debian Bookworm with the Raspberry Pi Desktop) for the model called Raspberry Pi 4.</p> <ol> <li>Insert the microSD card to the Raspberry Pi's board, plug in the power adapter to a wall socket, and insert the cable into the USB-C power slot of the Raspberry Pi. If you're going to use an external keyboard and mouse, insert the USB receivers for these devices into the USB ports of the Raspberry Pi.</li> <li>Turn on the power switch of the wall socket. The light on the Raspberry Pi board should glow green, and the display screen should first show a rectangle of rainbow colours, and then finally show you the Raspberry Pi desktop screen.</li> <li>If you don't have an external keyboard and mouse, log in to the Raspberry Pi from your laptop:<ol> <li>Find the IP address of your nework gateway. To do so, on your laptop, open the command prompt, and type <code>ipconfig</code>. Then, note down the value that's displayed as Default Gateway.</li> <li>Start Angry IP Scanner. For the first box in the IP Range field, specify the value of the default gateway that you noted down in the previous step. For the second field, specify a number that's about 15-20 stops away. For example, if your default gateway is <code>192.168.4.1</code>, specify the end range to be something around <code>192.168.4.15</code>, so that the scan doesn't take too long. (The assumption here is that you don't already have more than 15-20 devices connected to your network!) Click Start and wait for the scan to be over. Then, in the Hostname column, look for the name of your Raspberry Pi. This is the name that you specified as the hostname in the OS Customisation settings while downloading the operating system on the microSD card. When you've spotted this hostname, look for the entry in the IP column. You need this value in the next step.</li> <li>On your laptop, start PuTTY and enter the IP address of your Raspberry Pi. This is the value that you noted down in your previous step. Click Open. When prompted for login credentials, enter the user name and password that you specified in the OS Customisation settings while downloading the operating system on the microSD card. You should now see a prompt like this: <code>&lt;hostname&gt;@&lt;username&gt;:~ $</code>. For example, if your hostname is <code>delphi</code> and user name is <code>oracle</code>, you'll see <code>delphi@oracle:~ $</code>It means you're now logged in to your Raspberry Pi and everything's working as expected.</li> </ol> </li> <li>Update the operating system that you installed on the microSD card. You used Raspberry Pi Imager for downloading the operating system but it might not contain the latest patches, fixes, and upgrades. Pull these things in:<ol> <li>Open a terminal window. If you're logged in through your laptop, you're already in the terminal window. If you're using an external keyboard and mouse, move the mouse over the icons at the top left, locate the one labelled Terminal, and click it.</li> <li>To see if there are any updates to the operating system, run the following command: <code>sudo apt-get update</code>. The local cache of the Raspberry Pi is updated with the package information for the package repositories. You're shown a list of the these packages, and now it's up to you to upgrade them to their latest versions.</li> <li>Upgrade the software shown on the list by running the following command: <code>sudo apt-get upgrade</code>. When prompted for permission to proceed with the upgrade, answer in the affirmative. The actual updates for the installed software and the operating system are now downloaded and installed on your Raspberry Pi. </li> </ol> </li> <li>If you don't have an external mouse or keyboard, set up Raspberry Pi Connect so that you can control the Raspberry Pi through a laptop through the Raspberry Pi's desktop GUI itself. You're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal window: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in. </li> </ol> </li> <li>If you're not immediately proceeding to the next step (where you write the Python program), shut down the Raspberry Pi.<ol> <li>If you're using an external mouse, close the terminal window. Then click the Raspberry Pi icon near the top left and click Shutdown &gt; Shutdown. Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> <li>If you're logged in through your laptop, type the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> </li> </ol> <p>Now that your Raspberry Pi is ready to be used as a computer, you can proceed to creating the clock chimes.</p>"},{"location":"topics/clock_chimes_steps/#write-the-python-code-for-playing-the-clock-chimes","title":"Write the Python code for playing the clock chimes","text":"<p>For this clock-chiming project, the job of chiming on the hour and half-hour will be done by a Python program.</p> <p>The operating system that you installed on the Raspberry Pi already includes Python, as well as an integrated development environment (IDE) that makes it easier for you to write, run, and edit Python programs. This IDE is the Thonny IDE. You'll use Thonny to write the Python program.</p> <ol> <li>Plug in the speaker to the Raspberry Pi, and switch both of them on.</li> <li>If you don't have an external keyboard or mouse, log in remotely to your Raspberry Pi by using Connect:<ol> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should then see the Raspberry Pi desktop in your laptop browser window.</li> </ol> </li> <li>Install any patches, fixes, and upgrades that might have been made to the operating system by opening the Raspberry Pi terminal window (the console icon near the top left) and running the following two commands one after the other:<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt-get upgrade</code></li> </ul> </li> <li>Open Thonny by clicking the Raspberry Pi icon near the top left, and then clicking Programming &gt; Thonny.</li> <li>Create a virtual environment for your project. A virtual environment is like a boxed enclosure that contains all the Python libraries and packages that are needed for your code to run. Click Tools &gt; Options, and then click Interpreter. Make sure that the interpreter is <code>Local Python 3</code>. Then, click New virtual environment and follow the onscreen guidance to create an empty folder and designate it as the place where your project will live. When everything's done, click OK.</li> <li>Open a new file by clicking File &gt; New. Copy into it the code from The code section of this page.</li> <li>In the same virtual environment, at the same location as the <code>.py</code> file, paste a sound file containing the music you want to be played as the chimes. This sound file should be a <code>.wav</code> file because the <code>pygame</code> library can play only <code>.wav</code> files. For this project, I downloaded a royalty-free sound file that had peeling church bells, and then edited the file in to separate out a 2-second clip of a dinging sound.</li> <li>Install a Python package called <code>pygame</code> in the virtual environment. To do so, click Tools &gt; Manage packages, search for <code>pygame</code>, and click Install.</li> <li>Edit line 7 of the Python code to make sure that the file name is correct. For example, if your sound file is called <code>dingdong.wav</code>, line 7 should be <code>sound_file = 'dingdong.wav'</code>.</li> <li>Save the file, and click the Run icon. Wait for the half hour or the hour. You should be able to hear the chimes.</li> </ol>    Your browser does not support the video tag."},{"location":"topics/clock_chimes_steps/#the-code","title":"The code","text":"<p><pre><code>import time\nfrom datetime import datetime\nimport pygame\n\n# Initialize pygame mixer\npygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)\nsound_file = 'ding.wav'\nchime_sound = pygame.mixer.Sound(sound_file)\n\ndef play_chime(times):\n    \"\"\"Play the chime the specified number of times.\"\"\"\n    for _ in range(times):\n        chime_sound.play()\n        time.sleep(2)  # A 2-second delay between chimes\n\ntry:\n    print('Chiming on the hour and half-hour. Press Ctrl+C to stop.')\n    while True:\n        now = datetime.now()\n        current_minute = now.minute\n        current_second = now.second\n\n        if current_minute == 30:\n            # Chime once for the half-hour\n            print('Chiming once for the half-hour.')\n            play_chime(1)\n            # Sleep until the top of the next hour\n            sleep_time = (60 - current_minute) * 60 - current_second\n            time.sleep(sleep_time)\n        elif current_minute == 0:\n            # Chime the number of times equal to the hour\n            chime_count = now.hour % 12 or 12  # Use 12 for midnight and noon\n            print(f'Chiming {chime_count} times for the hour {now.hour}.')\n            play_chime(chime_count)\n            # Sleep until the half-hour\n            sleep_time = 30 * 60 - current_second\n            time.sleep(sleep_time)\n        else:\n            # Determine whether to sleep until the half-hour or the hour\n            if current_minute &lt; 30:\n                sleep_time = (30 - current_minute) * 60 - current_second\n            else:\n                sleep_time = (60 - current_minute) * 60 - current_second\n            time.sleep(sleep_time)\n\nexcept KeyboardInterrupt:\n    print('\\nStopped chiming.')\n</code></pre> You can also download the raw Python file.</p> <p>Notice the first three lines of the code.</p> <pre><code>import time\nfrom datetime import datetime\nimport pygame\n</code></pre> <p>This is where you import the libraries and packages that are needed for this project. A Python library is a collection of programs that do a specific task, and can be called in your program by their name. Libraries make it easy to do things that would've otherwise needed you to write out, manually, the several lines of code needed to do that thing. For example, assume you need to count the number of words in a sentence. The manual (non-library) way of doing so would be to write something like this:</p> <pre><code>sentence = 'Beside the lake, beneath the trees, fluttering and dancing'\nword_counts = {}\nwords = sentence.split()  # Split the sentence into words\nfor word in words:\n    word = word.lower().strip(\".,!?\")  # Remove punctuation\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>Now, imagine doing the same thing with a library called <code>collections</code>, which contains code to do the heavy lifting. If you were to use this library, your code would look something like this, where you use a class called <code>Counter</code> to do the counting:</p> <pre><code>from collections import Counter\n\n# Count word occurrences using a library\nsentence = 'There was a time when meadow, grove, and stream, and every common sight to me did seem apparelled in celestial light.'\nwords = sentence.lower().split()\nnormalized_words = [word.strip(\".,!?\") for word in words]\nword_counts = Counter(normalized_words)\n\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>With libraries, you can write your programs with fewer lines of code, while using universal methods that can be recognised by any other Python programmer more easily than if they had to read non-library code.</p> <p>Some libraries are included by default in every Python installation. The libraries called <code>time</code> and <code>datetime</code>, which are imported in the first two lines, are such libraries. Some other libraries are ones that you manually install in the virtual environment of your project. The <code>pygame</code> library is one such library. It is a library for handling multimedia files like the sound file you use in this project.</p> <p>Take a look at this part of the code:</p> <pre><code>time.sleep(2)  # A 2-second delay between chimes\n</code></pre> <p>This bit specifies a 2-second delay when the chimes are going to be repeated for the number of hours. For example, if it is 4 o'clock, the playing is repeated four times, with a 2-second delay between the repetitions.</p> <p>Look at how <code>sleep_time</code> is calculated. It takes into account the seconds that have elapsed while the sound was playing; therefore, this <code>sleep_time</code> is calculated twice, once on the hour and once on the half-hour.</p> <pre><code>sleep_time = (60 - current_minute) * 60 - current_second\n\n...\n\nsleep_time = 30 * 60 - current_second\n</code></pre> <p>Take a look at this bit, which controls the number of times the chime is played:</p> <pre><code>play_chime(1)\n\n...\n\nplay_chime(chime_count)\n</code></pre> <p><code>chime_count</code> is calculated according to the current hour, as follows: <code>chime_count = now.hour % 12 or 12</code>. The reason for using a modulus operation rather than a substraction operation (like <code>chime_count = now.hour - 12</code>) is explained in the following table.</p> <code>now.hour</code> Modulus (<code>now.hour % 12</code>) Substraction (<code>now.hour - 12</code>) Notes 13 1 1 Both methods return the correct hour. 14 2 2 Both methods return the correct hour. 23 11 11 Both methods return the correct hour. 0 (midnight) 0 - 12 Incorrect. Solved by using <code>or 12</code> in the modulus operation. 12 (noon) 0 0 Incorrect. Solved by using <code>or 12</code> in the modulus operation. <p>Notice the <code>or</code> operater in <code>chime_count = now.hour % 12 or 12</code>. This code sets the value of the <code>chime_count</code> variable to the modulus value, but if the modulus is zero, sets the <code>chime_count</code> value to 12.</p> <p>Now, see this bit near the start of the code:</p> <pre><code>pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=4096)\n</code></pre> <p>This code initialises the <code>pygame</code> module with the following parameters: - <code>frequency</code>, which is set to match my sound file's sample rate. To find the sample rate of your sound file, run the following command from the Raspberry Pi terminal: <code>file &lt;filename.wav&gt;</code>, where <code>filename.wav</code> must be replaced by the name of your sound file. You should get an output that's something like this: <code>RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz</code> - <code>size</code>, which is the bit-depth of the sound file. In my case, because the format is <code>PCM</code>, a negative sign (<code>-16</code>) is used, which is standard for PCM data.  - <code>channels</code>, which is set to <code>2</code> because my audio device is a dual-channel speaker. - <code>buffer</code>, increased from the default of <code>2048</code> to remove any stuttering.</p> <p>You can also do a simpler initialisation, without specifying the parameters, like this: <code>pygame.mixer.init()</code>.  But sometimes, doing so might lead to the sound file seeming to stutter on playback due to buffering issues.</p>"},{"location":"topics/clock_chimes_steps/#troubleshooting-the-code","title":"Troubleshooting the code","text":"<p>1.  <code>pygame</code> not found</p> <p>If <code>pygame</code> does not show up in the search results when you try to install it through Tools &gt; Manage packages:</p> <ol> <li>Close Thonny.</li> <li>Open the terminal and run the following two commands one after the other:<ul> <li><code>sudo apt update</code></li> <li><code>sudo apt install python3-full</code> </li> </ul> </li> <li>Go to the directory that contains your project files, and look for a file called <code>pyvenv.cfg</code>. Right-click the file, click Text editor, and make sure the value of <code>include-system-site-packages</code> is set to <code>true</code>. Save the file, and close it.</li> <li>Reopen Thonny, and click Tools &gt; Manage packages. </li> </ol> <p>You should now be able to see <code>pygame</code> in the list of installed packages.</p> <p>2.  Stuttering playback</p> <p>If your sound file plays perfectly on your laptop but seems to be stuttering on the Raspberry Pi computer, the problem might lie with buffering. Increase the buffer size to <code>8192</code> or higher when initialising the <code>pygame</code> library at line 6.</p>"},{"location":"topics/photo_frame_intro/","title":"Digital photo frame","text":"<p>A digital photo frame is an LED device that can display pictures. It's similar to an LCD TV, inasmuch as you can plug in a USB flash drive to the TV port and view the pictures. A photo frame, however, isn't as large as a typical TV. Quite a few digital frames also have speakers, just like TVs do, so that you can view movie clips as well. Unlike a TV, where you must scroll through the pictures manually, a digital photo frame can be configured to display pictures in a continuous loop, advancing to the next picture after a specified time period.</p> <p> To see a larger image, click the image.</p> <p>This project uses a Raspberry Pi 3B+ computer and a Raspberry Pi Touch Display to make a digital photo frame. To make it all work, you must set up a headless Raspberry Pi computer, connect it to a screen, and then run Python on it. It doesn't matter if you don't know Python, because I'll provide the entire code for you to use. If you do know Python, you can tweak the code to include the enhancements that I'll suggest at the end of the tutorial.</p>"},{"location":"topics/photo_frame_intro/#materials","title":"Materials","text":"<p>For the photo frame:</p> <ul> <li>A Raspberry Pi 3B+ computer. This little computer board will hold the code that displays the photos.</li> <li>A Raspberry Pi 7\" official touch display. This screen is where the photos are displayed. You can choose to use any other display screen that can be used with a Raspberry Pi 3B+, but I used the official display because it's a plug-and-play set up.</li> <li>A Raspberry Pi official power adapter. Theoretically, any adapter with a USB-C cable that can plug into the Raspberry Pi should work fine. In practice, it's better to get the official power adapter because it's been tested to deliver the exact power that the Raspberry Pi needs.</li> <li>A microSD card. This tiny card will contain the operating system that your Raspberry Pi will run on.</li> <li>A USB drive. This flash drive will contain your photos.</li> <li>(Optional) Heat sinks. These are little metal blocks that draw the heat away from the chips on the Raspberry Pi board. A Python program for this project should not heat the Raspberry Pi too much, but it is safe practice to use heat sinks.</li> <li>(Optional) An external keyboard and a mouse. These two things are optional, because you can use your laptop keyboard and touchpad to issue commands to the Raspberry Pi computer.</li> </ul> <p>To set up the Raspberry Pi:</p> <ul> <li>A laptop (or desktop), with a microSD port. If your laptop does not have this port, you need a microSD card reader that you can plug into laptop. After the Raspberry Pi is set up and the photo frame is working, you'll no longer need the laptop.</li> <li>Administrator privileges on the laptop, so that you can download all the required software on it.</li> <li>An internet connection. After the set up is complete, this project does not need an internet connection.</li> </ul>"},{"location":"topics/photo_frame_intro/#steps","title":"Steps","text":"<p>To build the photo frame, you first connect the touch display screen to the Raspberry Pi, then make the Raspberry Pi ready by installing an operating system on it, and finally write a script to display your photo collection. A step-by-step guide is at how to make a digital photo frame.</p>"},{"location":"topics/photo_frame_intro/#cost","title":"Cost","text":"<p>All figures are in Indian Rupees (INR), and inclusive of GST (goods and service tax).</p> Item Amount (INR) Raspberry Pi 3 Model B 3,538.82 12.5W Official Raspberry Pi Micro USB Power Supply 708.00 Raspberry Pi Official 32GB V3.0 , A2 Class Micro SD 398.84 Aluminium Heat Sink 35.40 Official Raspberry Pi 7\" Touch Display 6,372.00 Raspberry Pi 4 Model B Touchscreen 7 inch Display Case -ABS, Black 849.00 11,902.06"},{"location":"topics/photo_frame_intro/#alternatives","title":"Alternatives","text":"<p>This project is not the only way that you can get a digital photo frame up and running on a Raspberry Pi. Here are some alternatives:</p> <ul> <li>PiGallery2. After you've set up your Raspberry Pi, as descibed in steps 1 through 4 of this project, you must run a server on your Raspberry Pi, and then install and run PiGallery2. See How to set up Raspberry Pi as a server and How to install PiGallery2 on Raspberry Pi.</li> <li>InkyPi. After you've set up your Raspberry Pi, as described in steps 1 through 4 of this project, you must attach the Pimoroni Inky Impression display to the Raspberry Pi, and then install and run InkyPi.</li> <li><code>imv</code> package. After you've set up your Raspberry Pi, as descibed in steps 1 through 4 of this project, you write a Python script to use the <code>imv</code> package, which is a command line image viewer. See Photo frame at PiMyLifeUp.</li> </ul>"},{"location":"topics/photo_frame_intro/#motivation","title":"Motivation","text":"<p>Why I went in for this project? It's because of a broken photo frame at home. I had gifted the frame to my brother about a decade and a half ago. It has started showing its age: photos displayed with random rainbow stripes or the screen displaying snowshowers intermittently. A search on Amazon revealed that reputed photo companies (such as Sony, Kodak, etc.) no longer made these photo frames. Because I wasn't willing to go with cheaper local alternatives, I had to pull my sleeves up and get into the first ever Raspberry Pi project of my life. With zero knowledge of single computer boards and their workings.</p>"},{"location":"topics/photo_frame_steps/","title":"Make a digital photo frame","text":"<p>The steps to build the digital photo frame are these:</p> <ol> <li>Attach the touch display to the Raspberry Pi board.</li> <li>Attach the heat sinks to the Raspberry Pi board.</li> <li>Prepare your laptop.</li> <li>Download the Raspberry Pi operating system.</li> <li>Install the operating system.</li> <li>Write the Python code that displays the photos.</li> <li>Refine the project.</li> </ol> <p> To see a larger image, click the image.</p>"},{"location":"topics/photo_frame_steps/#attach-a-touch-display-to-the-raspberry-pi-board","title":"Attach a touch display to the Raspberry Pi board","text":"<p>The Raspberry Pi is what they call an SBC (a single board computer). It has neither a screen where you can see the output of your commands, nor a keyboard through which you can send these commands to the computer. It is just a barebones computer, with no peripheral devices such as keyboard, mouse, monitor, speaker, or microphone. To use a Raspberry Pi as a computer, you must manually attach these peripherals to it. </p> <p>Here, you're not going to use the Raspberry Pi as a computer, but you are building a photo frame. Therefore, the barest minimum peripheral device that you need is a display screen.</p> <p>These are the materials that you need.</p> Front viewBack view <p> To see a larger image, click the image. </p> <p> To see a larger image, click the image. </p> <p>Notice the left side of both the images. At the top left quadrant is the Raspberry Pi board. At the bottom left is the power supply, the heat sinks, and the microSD card. These objects, when put together, constitute a standalone Raspberry Pi computer that you can use to do...stuff. Like building a digital photo frame.</p> <p>Look at the right half of both the images. The objects there are what's included in an official pack of the Raspberry Pi Touch Display. When plugged into a Raspberry Pi computer (which you can assemble from the materials at the left), this set becomes the display unit for the Raspberry Pi computer. </p> <p>Notice the view of the display screen from the back (second image, upper right quadrant).  The green board, called the controller board, has four little screws at the four corners. To mount the display screen on to the Raspberry Pi, you loosen these four screws at the four ends of the controller board of the display screen, place the Raspberry Pi on to it, and put the screws back in place.</p> <p>You then connect these two boards by means of two wires (red and black) and a cable (the white straight strip), which you can see at the bottom right quadrant of the images. Two things to note here:</p> <ul> <li>You don't need the shiny curved strip also shown in the picture; it came as standard packaging with the display and is used in Raspberry Pi 4 models. The model being used here, in this project, is Raspberry Pi 3B+, so the straight white strip is the one to use. In the Raspberry Pi world, strips like these are known as ribbon cables.</li> <li>You also don't need the yellow wire and the green wire. In the Raspberry Pi world, this kind of wire is called a jumper cable. Your photo frame uses a Raspberry Pi 3B+, which needs only two jumper cables, the red and the black. The yellow and green jumper cables are needed only if you're using an older model of the Raspberry Pi, one that does not have a 40-pin GPIO strip. For this tutorial, the GPIO pins aren't the focus so they won't be discussed, but if you're curious, you can read up on <code>GPIO</code>, <code>SCL</code>, and <code>SDA</code> pins.</li> </ul> <p>When you're done with attaching the display screen to the Raspberry Pi, the entire assembly should look something like this image (taken from <code>https://www.raspberrypi.com/documentation/accessories/display.html</code>):</p> <p> To see a larger image, click the image.</p> <p>I found this YouTube video helpful. It shows the steps to attach the display screen to the Raspberry Pi board.</p> <p>If you'd rather read some written instructions, see this official guide from the good folks at Raspberry Org: Touch Display.</p> <p>After the display screen is mounted on the computer board, fix the heat sinks.</p>"},{"location":"topics/photo_frame_steps/#fix-heat-sinks-to-the-raspberry-pi-board","title":"Fix heat sinks to the Raspberry Pi board","text":"<p>A heat sink is a square, metal object that is attached to a Raspberry Pi board by means of thermal paste. It draws the heat away from the processor, the USB controller, and the ethernet controller. A photo frame program running on a Raspberry Pi 3B+ should not heat the little computer too much, but it is safe practice to use heat sinks. </p> <p>The three small corrugated squares that you see at the bottom left of the image are heat sinks. In the Raspberry Pi world, these corrugations are known as fins.</p> <p> To see a larger image, click the image.</p> <p>Notice that the image shows three heat sinks.  A Raspberry Pi Model 3B+ needs only two of those. It's the Raspberry Pi 4 model that would've needed all three heat sinks, but because these heat sinks hardly cost anything, shops in my corner of the world usually sell them in sets of 3.</p> <p>Attach the heat sinks to the CPU chip and the network chip of the Raspberry Pi board. The one that goes over the CPU chip is the largest one; the one to use on the ethernet board is the smallest one.</p> <ol> <li>Peel off the adhesive strip at the back of the heat sink, all the while taking care that you don't touch the sticky part that the strip was covering. The sticky part is the thermal paste that will hold the sink in place.</li> <li>Press the sink ever so slightly on to the chip on the Raspberry Pi board.</li> </ol> <p>I found this YouTube video to be helpful.</p> <p>After the heat sinks are in place, prepare your laptop for the Raspberry Pi setup.</p>"},{"location":"topics/photo_frame_steps/#prepare-your-laptop-for-the-raspberry-pi-installation","title":"Prepare your laptop for the Raspberry Pi installation","text":"<p>Before you can use your laptop to run a Raspberry Pi OS installation, make sure that the following software is available on it.</p> <ul> <li>Download SD Memory Card Formatter. Before you can load an operating system on your microSD card, you must format it. Use the formatter provided by the SD Association because this formatter is platform-agnostic. </li> <li>Download Raspberry Pi Imager. The good folks at Raspberry Org have created a wizard that can install an operating system on a microSD card and also, simultaneously, configure the operating system with the barest minimum parameters that are needed to get a Raspberry Pi computer up and running. This wizard is known as Raspberry Pi Imager. </li> <li>Download Angry IP Scanner. If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. To do so, you need the IP address of the Raspberry Pi. A network scanner can show you the IP addresses of all devices that are connected to your network. One such network scanner is Angry IP Scanner, so download it.</li> <li>Download PuTTY.  If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. One of the ways to do so is by using a secure shell (SSH) connection. PuTTY is an SSH client through which you can interactively run a command-line session on your Raspberry Pi. </li> <li>(Optional) Download WinSCP. If you need to transfer files to and from the Raspberry Pi computer, you need a secure file-transfer client. WinSCP is one such client. </li> </ul> <p>When you're done, you should have the following software on your laptop. </p> <p></p> <p>You are now ready to install an operating system on your Raspberry Pi.</p>"},{"location":"topics/photo_frame_steps/#download-the-operating-system","title":"Download the operating system","text":"<p>For this step, you need a microSD card and a card reader that can be plugged into your laptop.</p> <p>The operating system will be downloaded on to the microSD card, which will then be inserted into the microSD slot of the Raspberry Pi board, which will then be plugged into a power socket. That's what will get the little board up and running, and make it ready for the final steps of the project.</p> <ol> <li>Turn on your laptop. Make sure that it is connected to the internet.</li> <li>Plug the microSD card into your laptop, and format it by running SD Card Formatter. Use the Overwrite option to format; this option takes longer but ensures that everything on the SD card is wiped clean and the card formatted.</li> <li>On the laptop, run the Raspberry Pi Imager wizard and download Raspberry Pi's operating system to it. All Raspberry Pi computers run on  operating systems that are based on the open-source Debian operating system. This project uses Debian Bookworm with the Raspberry Pi Desktop. Begin the download process by selecting the model as Raspberry Pi 3 and the operating system as Raspberry Pi OS 64-bit (A port of Debian Bookworm with the Raspberry Pi Desktop).</li> <li>On the page for OS customisation, click Edit settings. These settings are used for configuring the operating system with your credentials and environment. If prompted for loading Wi-Fi credentials from your host computer, respond in the affirmative. Then, specify the values for at least the following parameters. It's also a good idea to note down these values for easy reference, because you'll need these values later:<ul> <li>On the General page:<ul> <li>hostname, which is a name you call your Raspberry Pi by. This is the name that'll be displayed when you search for your Raspberry Pi on the network later.</li> <li>username and password, which are the credentials to use when logging in to Raspberry Pi remotely. The user name that you specify here will have administrator privileges to your Raspberry Pi.</li> <li>Wireless LAN, which should be prepopulated because you already asked the Wi-Fi credentials to be loaded from the host computer.</li> <li>Locale settings, for your time zone, keyboard preferences, and other such locale-related things.</li> </ul> </li> <li>On the Services page, select the Enable SSH box and the option for password authentication. Later, when the project is up and running, you might choose to isolate your Raspberry Pi from the network, and if you decide to do that, you can turn SSH off, but for the time being, enable it because you might need it for troubleshooting purposes.</li> <li>On the Options page, select all the options.</li> </ul> </li> <li>Click Save and, when prompted for applying these settings, answer in the affirmative. Click Yes again, and then wait for the operating system to be copied on to the microSD card.</li> <li>When the process is complete, take the microSD card out of the laptop port.</li> </ol>"},{"location":"topics/photo_frame_steps/#install-the-operating-system","title":"Install the operating system","text":"<p>For this project, you install the operating system called Raspberry Pi OS 64-bit (A port of Debian Bookworm with the Raspberry Pi Desktop) for the model called Raspberry Pi 3.</p> <ol> <li>Insert the microSD card to the Raspberry Pi's board, plug in the power adapter to a wall socket, and insert the cable into the USB-C power slot of the Raspberry Pi. If you're going to use an external keyboard and mouse, insert the USB receivers for these devices into the USB ports of the Raspberry Pi.</li> <li>Turn on the power switch of the wall socket. The light on the Raspberry Pi board should glow green, and the display screen should first show a rectangle of rainbow colours, and then finally show you the Raspberry Pi desktop screen.</li> <li>If you don't have an external keyboard and mouse, log in to the Raspberry Pi from your laptop:<ol> <li>Find the IP address of your nework gateway. To do so, on your laptop, open the command prompt, and type <code>ipconfig</code>. Then, note down the value that's displayed as Default Gateway.</li> <li>Start Angry IP Scanner. For the first box in the IP Range field, specify the value of the default gateway that you noted down in the previous step. For the second field, specify a number that's about 15-20 stops away. For example, if your default gateway is <code>192.168.4.1</code>, specify the end range to be something around <code>192.168.4.15</code>, so that the scan doesn't take too long. (The assumption here is that you don't already have more than 15-20 devices connected to your network!) Click Start and wait for the scan to be over. Then, in the Hostname column, look for the name of your Raspberry Pi. This is the name that you specified as the hostname in the OS Customisation settings while downloading the operating system on the microSD card. When you've spotted this hostname, look for the entry in the IP column. You need this value in the next step.</li> <li>On your laptop, start PuTTY and enter the IP address of your Raspberry Pi. This is the value that you noted down in your previous step. Click Open. When prompted for login credentials, enter the user name and password that you specified in the OS Customisation settings while downloading the operating system on the microSD card. You should now see a prompt like this: <code>&lt;hostname&gt;@&lt;username&gt;:~ $</code>. For example, if your hostname is <code>delphi</code> and user name is <code>oracle</code>, you'll see <code>delphi@oracle:~ $</code>It means you're now logged in to your Raspberry Pi and everything's working as expected.</li> </ol> </li> <li>Update the operating system that you installed on the microSD card. You used Raspberry Pi Imager for downloading the operating system but it might not contain the latest patches, fixes, and upgrades. Pull these things in:<ol> <li>Open a terminal window. If you're logged in through your laptop, you're already in the terminal window. If you're using an external keyboard and mouse, move the mouse over the icons at the top left, locate the one labelled Terminal, and click it.</li> <li>To see if there are any updates to the operating system, run the following command: <code>sudo apt-get update</code>. The local cache of the Raspberry Pi is updated with the package information for the package repositories. You're shown a list of the these packages, and now it's up to you to upgrade them to their latest versions.</li> <li>Upgrade the software shown on the list by running the following command: <code>sudo apt-get upgrade</code>. When prompted for permission to proceed with the upgrade, answer in the affirmative. The actual updates for the installed software and the operating system are now downloaded and installed on your Raspberry Pi. </li> </ol> </li> <li>If you don't have an external mouse or keyboard, set up Raspberry Pi Connect so that you can control the Raspberry Pi through a laptop through the Raspberry Pi's desktop GUI itself. You're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal window: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in. </li> </ol> </li> <li>If you're not immediately proceeding to the next step (where you write the Python program), shut down the Raspberry Pi.<ol> <li>If you're using an external mouse, close the terminal window. Then click the Raspberry Pi icon near the top left and click Shutdown &gt; Shutdown. Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> <li>If you're logged in through your laptop, type the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> </li> </ol> <p>Now that your Raspberry Pi is ready to be used as a computer, you can proceed to creating the Python script that displays your photo collection.</p>"},{"location":"topics/photo_frame_steps/#write-the-python-code-for-displaying-the-photos","title":"Write the Python code for displaying the photos","text":"<p>A digital photo frame reads photo files from a storage device, and displays them on the screen for a specified time. For the photo frame that you're building, this job will be done by a Python program.</p> <p>The operating system that you installed on the Raspberry Pi already includes Python, as well as an integrated development environment (IDE) that makes it easier for you to write, run, and edit Python programs. This IDE is the Thonny IDE. You'll use Thonny to write the photo frame program.</p> <ol> <li>Plug in the USB drive containing your photos to the Raspberry Pi, and switch it on.</li> <li>If you don't have an external keyboard or mouse, log in remotely to your Raspberry Pi by using Connect:<ol> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should then see the Raspberry Pi desktop in your laptop browser window.</li> </ol> </li> <li>Install any patches, fixes, and upgrades that might have been made to the operating system by opening the Raspberry Pi terminal window (the console icon near the top left) and running the following two commands one after the other:<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt-get upgrade</code></li> </ul> </li> <li>Open Thonny by clicking the Raspberry Pi icon near the top left, and then clicking Programming &gt; Thonny.</li> <li>Create a virtual environment for your project. A virtual environment is like a boxed enclosure that contains all the Python libraries and packages that are needed for your code to run. Click Tools &gt; Options, and then click Interpreter. Make sure that the interpreter is <code>Local Python 3</code>. Then, click New virtual environment and follow the onscreen guidance to create an empty folder and designate it as the place where your project will live. When everything's done, click OK.</li> <li>Open a new file by clicking File &gt; New. Copy into it the code from The code section of this page. Then, edit line 20 to change <code>usb_dir = '/media/pi/'</code> to <code>usb_dir = '/media/&lt;yourPiUserName&gt;/'</code>. For example, if the user name that you specified when setting up the Raspberry Pi was <code>oracle</code>, line 20 in the code should be <code>usb_dir = '/media/oracle/'</code>.</li> <li>Install a Python package called <code>Pillow</code> in the virtual environment. To do so, click Tools &gt; Manage packages, search for <code>Pillow</code>, and click Install.</li> <li>Save the file, and click the Run icon. You should see your photos being picked up and displayed one after the other.</li> </ol>    Your browser does not support the video tag.  <p>Your photo frame is now ready. You can leave it as is now, or you might choose to refine it.</p>"},{"location":"topics/photo_frame_steps/#the-code","title":"The code","text":"<pre><code>import os\nimport time\nimport tkinter as tk\nfrom PIL import Image, ImageTk\n\n# Function to get a list of image files from a directory and its subdirectories\ndef get_image_files(directory):\n    image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif'}\n    image_files = []\n    for root, _, files in os.walk(directory):\n        for file in files:\n            if file.lower().endswith(tuple(image_extensions)):\n                image_files.append(os.path.join(root, file))\n    return image_files\n\n# Main function to run the digital photo frame\ndef digital_photo_frame():\n    # Directories to scan for images\n    local_dir = os.getcwd()  # Current working directory\n    usb_dir = '/media/pi/'  # The USB mount path in the Raspberry Pi\n    # Collect all image files\n    images = get_image_files(local_dir) + get_image_files(usb_dir)\n    if not images:\n        print(\"Couldn't find any image files in the specified directories.\")\n        return\n    # Create a Tkinter window\n    root = tk.Tk()\n    root.title('Raspberry Pi Photo Frame') # The title doesn't matter; it won't be displayed\n    # Fullscreen settings (optional)\n    root.attributes('-fullscreen', True)\n    root.bind(\"&lt;Escape&gt;\", lambda e: root.destroy())  # Exit fullscreen with the Esc key\n    # Label to display the image\n    label = tk.Label(root)\n    label.pack(expand=True, fill=tk.BOTH)\n    # Function to update the displayed image\n    def update_image(index):\n        img_path = images[index]\n        img = Image.open(img_path)\n        img = img.resize((root.winfo_screenwidth(), root.winfo_screenheight()), Image.Resampling.LANCZOS)\n        photo = ImageTk.PhotoImage(img)\n        label.config(image=photo)\n        label.image = photo\n        root.after(10000, update_image, (index + 1) % len(images))  # Change the image every 10 seconds\n    # Start displaying the first image\n    update_image(0)\n    # Run the Tkinter event loop\n    root.mainloop()\n\n# Run the script\nif __name__ == \"__main__\":\n    digital_photo_frame()\n</code></pre> <p> You can also download the raw Python file.</p> <p>Notice the first four lines of the code.</p> <pre><code>import os\nimport time\nimport tkinter as tk\nfrom PIL import Image, ImageTk\n</code></pre> <p>This is where you import all the libraries and packages needed for this project. A Python library is a collection of programs that do a specific task, and can be called in your program by their name. Libraries make it easy to do things that would've otherwise needed you to write out, manually, the several lines of code needed to do that thing. For example, assume you need to count the number of words in a sentence. The manual (non-library) way of doing so would be to write something like this:</p> <pre><code>sentence = 'Beside the lake, beneath the trees, fluttering and dancing'\nword_counts = {}\nwords = sentence.split()  # Split the sentence into words\nfor word in words:\n    word = word.lower().strip(\".,!?\")  # Remove punctuation\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>Now, imagine doing the same thing with a library called <code>collections</code>, which contains code to do the heavy lifting. If you were to use this library, your code would look something like this, where you use a class called <code>Counter</code> to do the counting:</p> <pre><code>from collections import Counter\n\n# Count word occurrences using a library\nsentence = 'There was a time when meadow, grove, and stream, and every common sight to me did seem apparelled in celestial light.'\nwords = sentence.lower().split()\nnormalized_words = [word.strip(\".,!?\") for word in words]\nword_counts = Counter(normalized_words)\n\nprint('This sentence contains`, word_counts, 'words.')\n</code></pre> <p>With libraries, you can write your programs with fewer lines of code, while using universal methods that can be recognised by any other Python programmer more easily than if they had to read non-library code.</p> <p>Some libraries are included by default in every Python installation. The libraries called <code>os</code>, <code>time</code>, and <code>tkinter</code>, called in the first three lines, are such libraries. Some other libraries are ones that you manually install in the virtual environment of your project. The <code>pillow</code> library, called here as <code>PIL</code>, is one such library. It is a library for handling images.</p> <p>Take a look at this part of the code:</p> <pre><code>image_extensions = {'.png', '.jpg', '.jpeg', '.bmp', '.gif'}\n</code></pre> <p>All the possible photo extensions are listed here, but if you think any is missing, go ahead and add it here. If any of your photos use extensions spelt in uppercase letters (for example, <code>.JPEG</code> or <code>.PNG</code>), it's a good idea to add them to this list too.</p> <p>See this bit of the code:</p> <pre><code># Fullscreen settings (optional)\nroot.attributes('-fullscreen', True)\nroot.bind(\"&lt;Escape&gt;\", lambda e: root.destroy())  # Exit fullscreen with the Esc key\n</code></pre> <p>You would've noticed that the display takes up the entire screen. Now, what if you need to stop the program from running? None of the Raspberry Pi controls are displayed anywhere. To take care of this eventuality, the <code>Esc</code> key of the keyboard has been bound to the action to stop the program midway.</p> <p>Take a look at this bit, which controls the time for which a photo is displayed:</p> <pre><code>root.after(10000, update_image, (index + 1) % len(images))  # Change the image every 10 seconds\n</code></pre> <p>The number <code>10000</code> is in milliseconds. It means, every photo is displayed for 10 seconds. You can change this value to whatever you want the time lag between photos to be.</p>"},{"location":"topics/photo_frame_steps/#troubleshooting-the-code","title":"Troubleshooting the code","text":"<p>If <code>Pillow</code> does not show up in the search results when you try to install it through Tools &gt; Manage packages:</p> <ol> <li>Close Thonny.</li> <li>Open the terminal and run the following two commands one after the other:<ul> <li><code>sudo apt update</code></li> <li><code>sudo apt install python3-full</code> </li> </ul> </li> <li>Go to the directory that contains your project files, and look for a file called <code>pyvenv.cfg</code>. Right-click the file, click Text editor, and make sure the value of <code>include-system-site-packages</code> is set to <code>true</code>. Save the file, and close it.</li> <li>Reopen Thonny, and click Tools &gt; Manage packages. </li> </ol> <p>You should now be able to see <code>Pillow</code> in the list of installed packages.</p>"},{"location":"topics/photo_frame_steps/#refine-the-project","title":"Refine the project","text":"<p>Now that your digital photo frame is working, consider incorporating the following enhancements to your project.</p> <ul> <li>Never go to sleep</li> <li>Touch to stop</li> <li>Pull from the cloud</li> <li>Make a stand</li> </ul>"},{"location":"topics/photo_frame_steps/#never-go-to-sleep","title":"Never go to sleep","text":"<p>Disable the screen blanking function of the Raspberry Pi. The screen can turn completely black after a period of inactivity. This means, if you start the Python program and then leave it on to loop through your pictures continuously, what might happen is that the screen will eventually turn blank. The Raspberry Pi is still on (and it hasn't gone to sleep), and the Python program is still running, but the screen is black because of inactivity.</p> <p>For this project, you installed Debian Bookworm on Raspberry Pi 3. By default, screen blanking is turned off in Debian Bookworm, so you shouldn't need to do anything further, but just for peace of mind, ensure that it's really turned off. Click the Raspberry Pi icon near the top of the screen, and then click Preferences &gt; Raspberry Pi Configuration &gt; Display. The screen blanking option should be turned off, similar to what's shown in the following image:</p> <p> To see a larger image, click the image.</p>"},{"location":"topics/photo_frame_steps/#touch-to-stop","title":"Touch to stop","text":"<p>Add a touch button to stop the Python script. The script you're using now can be stopped by pressing the <code>Esc</code> key on a keyboard, but you might not always have the USB receiver for the keyboard plugged into the Raspberry Pi. Stopping the script might become necessary in the following situations:</p> <ul> <li>To power down the Raspberry Pi.</li> <li>To load more photos on to the flash drive, in which case you must eject the drive, load the files into it, and then insert it back into the Raspberry Pi.</li> </ul> <p>Here's the code with stop-on-touch function. </p> <p>Notice the lines 44 through 50. These lines contain the code to stop the program with a touch or by clicking the left mouse-button. You add a small blue square near the bottom left corner, and you bind this square to the Stop action.</p> <pre><code># Add a blue button for touchscreen stop functionality\ndef stop_program(event):\n    root.destroy()\n# Create an overlay in the top-left corner (25x25 pixels) to detect touch\ntouch_exit_area = tk.Frame(root, width=25, height=25, bg=\"blue\")  # Blue for visibility purposes\ntouch_exit_area.place(x=0, y=0)\ntouch_exit_area.bind(\"&lt;Button-1&gt;\", stop_program)  # Bind left mouse button or touchscreen press\n</code></pre>"},{"location":"topics/photo_frame_steps/#pull-from-the-cloud","title":"Pull from the cloud","text":"<p>Have the Python display loop also include photos from a cloud drive.</p>"},{"location":"topics/photo_frame_steps/#make-a-stand","title":"Make a stand","text":"<p>Put the entire assembly into a case or stand. Doing so not only protects the computer boards from dust, but also gives support to the assembly so that it can stand on its own, without you having to use books or other such objects as props. I used a Multicomp Pro case, which was the only case available in my part of the world. Other options are a Pimoroni stand or a 3-D printed case from the designs at thingiverse.com.</p>"},{"location":"topics/security_camera_intro/","title":"Surveillance camera","text":"<p>Lakshman<sup>*</sup>, as the story goes, didn't sleep a wink for 14 years. During the day, he'd hunt with his elder brother, the exiled prince Ram, and during the night, he'd stand outside the leaf-hut he'd built for the prince and his wife, keeping an eye out for wandering evil elements. </p> <p>What if you too had your very own kid brother, like Lakshman, constantly keeping vigil outside your door?</p> InteriorExterior    Your browser does not support the video tag.     Your browser does not support the video tag.  <p>In this project, you use a Raspberry Pi Zero WH computer and a Camera Module 3 to build a surveillance system. You set up a headless Raspberry Pi computer, and write a bash script on it.</p>"},{"location":"topics/security_camera_intro/#materials","title":"Materials","text":"<p>For the security camera:</p> <ul> <li>A Raspberry Pi Zero WH computer. This little computer board will hold the code that makes the videos of your surroundings. The Raspberry Pi Zero is the smallest computer in the Raspberry Pi stable, and it is good enough for this project. The W in the name means it is WiFi enabled. The H in the name means the header pins are soldered into the Raspberry Pi board. This project does not need the H version but I got one just in case I want to use the header pins for something later.</li> <li>A Raspberry Pi Camera Module 3. For this project, I could've used an older camera module such as the Camera Module 2, which is lighter on the system resources (and the Raspberry Pi Zero hardly has any), but it doesn't support the <code>libcamera</code> package, which is going to be the officially supported package now .</li> <li>A Raspberry Pi official power adapter. Theoretically, any adapter with a microUSB cable that can plug into the Raspberry Pi should work fine. In practice, it's better to get the official power adapter because it's been tested to deliver the exact power that the Raspberry Pi needs.</li> <li>A microSD card. This tiny card will contain the operating system that your Raspberry Pi will run on.</li> </ul> <p>To set up the Raspberry Pi:</p> <ul> <li>A laptop (or desktop), with a microSD port. If your laptop does not have this port, you need a microSD card reader that you can plug into laptop. After the Raspberry Pi is set up and the camera is working, you'll no longer need the laptop unless you want to access the setup again.</li> <li>Administrator privileges on the laptop, so that you can download all the required software on it.</li> <li>An internet connection. After the set up is complete and the camera switched on, this project does not need an internet connection till you access the setup again to transfer video files to another computer.</li> </ul>"},{"location":"topics/security_camera_intro/#steps","title":"Steps","text":"<p>You make the Raspberry Pi ready by installing an operating system on it, and write a script to continuously record videos. A step-by-step guide is at make a surveillance camera.</p>"},{"location":"topics/security_camera_intro/#cost","title":"Cost","text":"<p>All figures are in Indian Rupees (INR), and inclusive of GST (goods and service tax).</p> Item Amount (INR) Raspberry Pi Zero WH 1,728.33 12.75W Micro USB Power Supply - Official 720.88 SanDisk 32GB MicroSDHC Memory Card 418.35 Raspberry Pi Camera Module 3 2,819.64 5,687.20"},{"location":"topics/security_camera_intro/#alternatives","title":"Alternatives","text":"<p>Any of the plug-and-play security cameras available off the shelf. They may or may not be more expensive, and might have all the bells and whistles.</p>"},{"location":"topics/security_camera_intro/#motivation","title":"Motivation","text":"<p>The push for this project came from two factors:</p> <ul> <li>The unavailablity (\"temporary\", I was told for 3 months before I lost patience) of a branded security camera solution from a well-known telecom company.</li> <li>My unwillingness to go in for the easily available off-the-shelf security cameras. These are all local brands and do not guarantee good performance.</li> </ul> <p>*: Lakshman is a prince of Ayodhya and a younger brother to the heir, Ram, according to the Indian epic, Ramayana. When Ram and his wife Sita were exiled, Lakshman accompanied them to keep guard.</p>"},{"location":"topics/security_camera_steps/","title":"Make a surveillance camera","text":"<p>These are the steps:</p> <ol> <li>Prepare your laptop.</li> <li>Download the Raspberry Pi operating system.</li> <li>Install the operating system.</li> <li>Attach the camera</li> <li>Write the bash code that makes the videos.</li> <li>Refine the project.</li> </ol> <p> To see a larger image, click the image.</p>"},{"location":"topics/security_camera_steps/#prepare-your-laptop-for-the-raspberry-pi-installation","title":"Prepare your laptop for the Raspberry Pi installation","text":"<p>Before you can use your laptop to run a Raspberry Pi OS installation, make sure that the following software is available on it.</p> <ul> <li>Download SD Memory Card Formatter. Before you can load an operating system on your microSD card, you must format it. Use the formatter provided by the SD Association because this formatter is platform-agnostic. </li> <li>Download Raspberry Pi Imager. The good folks at Raspberry Org have created a wizard that can install an operating system on a microSD card and also, simultaneously, configure the operating system with the barest minimum parameters that are needed to get a Raspberry Pi computer up and running. This wizard is known as Raspberry Pi Imager. </li> <li>Download Angry IP Scanner. If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. To do so, you need the IP address of the Raspberry Pi. A network scanner can show you the IP addresses of all devices that are connected to your network. One such network scanner is Angry IP Scanner, so download it.</li> <li>Download PuTTY.  If you don't plan to use an external mouse, keyboard, and monitor with your Raspberry Pi, you'll need to connect to it through your laptop. One of the ways to do so is by using a secure shell (SSH) connection. PuTTY is an SSH client through which you can interactively run a command-line session on your Raspberry Pi. </li> <li>(Optional) Download WinSCP. If you need to transfer files to and from the Raspberry Pi computer, you need a secure file-transfer client. WinSCP is one such client. </li> </ul> <p>When you're done, you should have the following software on your laptop. </p> <p></p> <p>You are now ready to install an operating system on your Raspberry Pi.</p>"},{"location":"topics/security_camera_steps/#download-the-operating-system","title":"Download the operating system","text":"<p>For this step, you need a microSD card and a card reader that can be plugged into your laptop.</p> <p>The operating system will be downloaded on to the microSD card, which will then be inserted into the microSD slot of the Raspberry Pi board, which will then be plugged into a power socket. That's what will get the little board up and running, and make it ready for the final steps of the project.</p> <ol> <li>Turn on your laptop. Make sure that it is connected to the internet.</li> <li>Plug the microSD card into your laptop, and format it by running SD Card Formatter. Use the Overwrite option to format; this option takes longer but ensures that everything on the SD card is wiped clean and the card formatted.</li> <li>On the laptop, run the Raspberry Pi Imager wizard and download Raspberry Pi's operating system to it. All Raspberry Pi computers run on  operating systems that are based on the open-source Debian operating system. This project uses Debian Bookworm with the Raspberry Pi Desktop. Begin the download process by selecting the model as Raspberry Pi Zero W and the operating system as Raspberry Pi OS 32-bit (A port of Debian Bookworm with the Raspberry Pi Desktop).</li> <li>On the page for OS customisation, click Edit settings. These settings are used for configuring the operating system with your credentials and environment. If prompted for loading Wi-Fi credentials from your host computer, respond in the affirmative. Then, specify the values for at least the following parameters. It's also a good idea to note down these values for easy reference, because you'll need these values later:<ul> <li>On the General page:<ul> <li>hostname, which is a name you call your Raspberry Pi by. This is the name that'll be displayed when you search for your Raspberry Pi on the network later.</li> <li>username and password, which are the credentials to use when logging in to Raspberry Pi remotely. The user name that you specify here will have administrator privileges to your Raspberry Pi.</li> <li>Wireless LAN, which should be prepopulated because you already asked the Wi-Fi credentials to be loaded from the host computer.</li> <li>Locale settings, for your time zone, keyboard preferences, and other such locale-related things.</li> </ul> </li> <li>On the Services page, select the Enable SSH box and the option for password authentication. Later, when the project is up and running, you might choose to isolate your Raspberry Pi from the network, and if you decide to do that, you can turn SSH off, but for the time being, enable it because you might need it for troubleshooting purposes.</li> <li>On the Options page, select all the options.</li> </ul> </li> <li>Click Save and, when prompted for applying these settings, answer in the affirmative. Click Yes again, and then wait for the operating system to be copied on to the microSD card.</li> <li>When the process is complete, take the microSD card out of the laptop port.</li> </ol>"},{"location":"topics/security_camera_steps/#install-the-operating-system","title":"Install the operating system","text":"<p>For this project, you install the operating system called Raspberry Pi OS 32-bit (A port of Debian Bookworm with the Raspberry Pi Desktop) for the model called Raspberry Pi Zero W.</p> <ol> <li>On the Raspberry Pi, locate the microSD card slot (it's midway between the mini-HDMI port and the header pins) and insert the microSD card into the slot.</li> <li>Plug in the Raspberry Pi power adapter to a wall socket, and insert the cable into the USB-C power slot of the Raspberry Pi. Turn on the power switch of the wall socket. The light on the Raspberry Pi board should glow green.</li> <li>Log in to the Raspberry Pi from your laptop:<ol> <li>Find the IP address of your nework gateway. To do so, on your laptop, open the command prompt, and type <code>ipconfig</code>. Then, note down the value that's displayed as Default Gateway.</li> <li>Start Angry IP Scanner. For the first box in the IP Range field, specify the value of the default gateway that you noted down in the previous step. For the second field, specify a number that's about 15-20 stops away. For example, if your default gateway is <code>192.168.4.1</code>, specify the end range to be something around <code>192.168.4.15</code>, so that the scan doesn't take too long. (The assumption here is that you don't already have more than 15 devices connected to your network!) Click Start and wait for the scan to be over. Then, in the Hostname column, look for the name of your Raspberry Pi. This is the name that you specified as the hostname in the OS Customisation settings while downloading the operating system on the microSD card. When you've spotted this hostname, look for the entry in the IP column. You need this value in the next step. </li> <li>Start PuTTY and enter the IP address of the Raspberry Pi. This is the value that you noted down in the previous step. Click Open. When prompted for login credentials, enter the user name and password that you specified in the OS Customisation settings while downloading the operating system on the microSD card. You should now see a prompt like this: <code>&lt;hostname&gt;@&lt;username&gt;:~ $</code>. For example, if your hostname is <code>delphi</code> and user name is <code>oracle</code>, you'll see <code>delphi@oracle:~ $</code>. It means you're now logged in to your Raspberry Pi and everything's working as expected.</li> </ol> </li> <li>Update the operating system that you installed on the microSD card. You used Raspberry Pi Imager for downloading the operating system but it might not contain the latest patches, fixes, and upgrades. Pull these things in.<ol> <li>To see if there are any updates to the operating system, run the following command: <code>sudo apt-get update</code>. The local cache of the Raspberry Pi is updated with the package information for the package repositories. You're shown a list of the these packages, and now it's up to you to upgrade them to their latest versions.</li> <li>Upgrade the software shown on the list by running the following command: <code>sudo apt-get upgrade</code>. When prompted for permission to proceed with the upgrade, answer in the affirmative. The actual updates for the installed software and the operating system are now downloaded and installed on your Raspberry Pi. </li> </ol> </li> <li>Set up Raspberry Pi Connect so that you can control the Raspberry Pi through a browser by using the Raspberry Pi's desktop GUI itself. At the moment, you're already logged into the Raspberry Pi through your laptop via SSH, but you can use only the terminal window when you're so logged in; you can't use the Raspberry Pi's desktop GUI. With the Connect software, you can log into your Raspberry Pi through any browser, and use it through its desktop environment.<ol> <li>Install Connect by running the following command in the terminal of the Raspberry Pi: <code>sudo apt install rpi-connect</code>.</li> <li>Start Connect by running the following command in the terminal of the Raspberry Pi: <code>rpi-connect on</code>.</li> <li>Generate a link that will connect your Raspberry Pi computer with your Connect account by running the following command from the terminal: <code>rpi-connect signin</code>. You're shown a sign-in URL on the terminal.</li> <li>On your laptop, open a browser, type the URL shown on the Raspberry Pi terminal window, and follow the onscreen prompts to complete the signin and authentication process.</li> <li>In the same browser window, specify a name to identify your device, and click Create device and sign in. </li> </ol> </li> <li>Shut down the Raspberry Pi by typing the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> <p>Now that your Raspberry Pi is ready to be used as a computer, you can proceed to attaching the camera module to it.</p>"},{"location":"topics/security_camera_steps/#attach-camera-module-3-to-raspberry-pi-zero-w","title":"Attach Camera Module 3 to Raspberry Pi Zero W","text":"<p>The 12-megapixel Camera Module 3 is the latest official camera module. </p> <p> To see a larger image, click the image.</p> <p>When you buy the camera module, you get two connector cables:</p> <ul> <li>A white one, which is a 40-pin-to-40-pin cable and made for the Raspberry Pi 3 and Raspberry Pi 4 models.</li> <li>A golden one, which is a 40-pin-to-22-pin cable and made for the Raspberry Pi 5 and Raspberry Pi Zero models.</li> </ul> <p>In the image, you also see a shorter golden cable. I bought this separately; it's also a 40-pin-to-22-pin cable but shorter.</p> <p>For this project, you must attach the camera module to the Raspberry Pi with the golden cable.</p> <ol> <li>Turn the camera module upside down, with the lens facing down. You see a metal clip. Loosen the clip by pulling down the two tiny clamps at the ends.</li> <li>Insert the broad end of the golden cable into this clip, taking care that the metal connectors are facing down (that is, towards the lens side). </li> <li>Push the clamps down, so that the clip sits firmly back in its place.</li> <li>On the Raspberry Pi, pull out the camera clip. It's located near the power port.</li> <li>Insert the narrower end of the cable, with the metal connectors facing the bottom side of the Raspberry Pi. Push the clamps down firmly. I took the help of this YouTube video that shows which clips to pull, push, and connect to.</li> <li> <p>Verify that the camera is working as expected:</p> <ol> <li>Switch on the Raspberry Pi.</li> <li>Open a terminal window and run the following command: <code>libcamera-jpeg -n -o test.jpg</code>. You should see several messages being written to the terminal, ending with a message saying that a picture was taken. This means that the camera module was detected and is working fine.</li> </ol> <p></p> </li> <li> <p>If you don't see a success message on the terminal, verify that the camera pins are firmly in place. Then, try to use the terminal messages to troubleshoot. An AI agent such as ChatGPT can help.</p> </li> <li>If you're not immediately proceeding to the next step, shut down the Raspberry Pi by typing the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol> <p>Now that the camera is in place, write the bash code for the surveillance setup.</p> <p>Because you're logged in through the terminal, you wouldn't be able to \"see\" the picture that you captured and saved as <code>test.jpg</code>. To see the image file, use the graphical interface of the Raspberry Pi computer itself and open the picture through its file manager. Here are the steps:</p> <ol> <li>Switch on Raspberry Pi.</li> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, you should see your Raspberry Pi. If you don't, wait for a few minutes and refresh the page.  Then, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should now see the Raspberry Pi desktop in your laptop browser.</li> <li>Open File Manager. It's one of the icons near the top where you see the Raspberry Pi icon.      </li> <li>In File Manager, go to <code>home/&lt;your user name&gt;</code>. You should see a file called <code>test.jpg</code>. To view the file, double-click it.</li> <li>When done, and if you're not immediately proceeding to the next step, shut down the Raspberry Pi by typing the following command on the terminal: <code>sudo shutdown -h now</code>. You should be disconnected from Raspberry Pi and the terminal window should disappear.  Wait till the green light on the Raspberry Pi board stops flashing, and then switch off the power supply.</li> </ol>"},{"location":"topics/security_camera_steps/#write-the-bash-code-for-the-surveillance-camera","title":"Write the bash code for the surveillance camera","text":"<p>A surveillance camera continuously records the happenings that it can 'see'. For this project, this job will be done by a bash script.</p> <p>The operating system that you installed on the Raspberry Pi already includes <code>libcamera</code>, which is the package that will be used for recording videos.</p> <ol> <li>Switch on the Raspberry Pi and wait for the green light to stop flashing.</li> <li>Log in remotely to your Raspberry Pi by using Connect:<ol> <li>On your laptop, open <code>https://connect.raspberrypi.com/</code> and sign in.</li> <li>On the Devices page, you should see your Raspberry Pi. If it isn't, wait for a few minutes and refresh the page.  Then, click Connect via &gt; Screen sharing, and wait for a few seconds for the remote session to start. You should then see the Raspberry Pi desktop in your laptop browser window.</li> </ol> </li> <li>Install any patches, fixes, and upgrades that might have been made to the operating system by opening the Raspberry Pi terminal window (the console icon near the top left) and running the following two commands one after the other:<ul> <li><code>sudo apt-get update</code></li> <li><code>sudo apt-get upgrade</code></li> </ul> </li> <li>Open a terminal window by clicking the Terminal icon near the top left. At the prompt, go to the <code>Videos</code> directory by typing the following command: <code>cd ~/Videos</code>. This is the directory that will contain the bash script and the videos.</li> <li>Open a new file by typing the following command: <code>nano simplevideo.sh</code>. The built-in code editor, called <code>nano</code>, opens. </li> <li>Copy into it the code from The script section of this page. Then, save the file and exit from the nano editor by doing these steps:<ol> <li>Press Ctrl + O. The editor displays the name that the file should be saved with. You've already specified it to be <code>simplevideo.sh</code>.</li> <li>Press Enter. The file is saved.</li> <li>Press Ctrl + X. You're taken back to the command prompt.</li> </ol> </li> <li>Turn the bash script into an executable file by typing the following command: <code>chmod +x simplevideo.sh</code>.</li> <li>Run the file by typing the following command: <code>./simplevideo.sh</code>. You should start seeing some messages on the screen.</li> </ol> <p>Go to the directory where your videos are being saved (Click the File Manager icon near the top left, right next to the Raspberry Pi icon). To view the video file, double-click the file.</p> <p>To stop the video recording at any time, in the terminal window, press Ctrl + C. If you see the script automatically start recording again, press Ctrl + C again. (This is expected behaviour. How to handle this behaviour better is explained in the \"Refine the project\" section.)</p>"},{"location":"topics/security_camera_steps/#the-script","title":"The script","text":"<p><pre><code>#!/bin/bash\nSAVE_PATH=\"/home/oracle/Videos\"\nmkdir -p \"$SAVE_PATH\"\n\nDURATION=$((60 * 1000))  # 1 minute in milliseconds\nwhile true; do\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout $DURATION -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\"\ndone\n</code></pre> You can also download the code file.</p> <p>Notice the second line of the script.</p> <pre><code>SAVE_PATH=\"/home/oracle/Videos\"\n</code></pre> <p>This is where you specify the directory to save the videos to. Replace <code>oracle</code> with the user name that you set up the Raspberry Pi with.</p> <p>Notice the next line:</p> <pre><code>DURATION=$((60 * 1000))  # 1 minute in milliseconds\n</code></pre> <p>The duration tells the script how long each video should be.</p> <p>Now look at the last bit:</p> <pre><code>libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout $DURATION -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\"\n</code></pre> <p>What's happening here that a video is being saved every 1 minute to the location you specified.</p> <ul> <li><code>libcamera-vid</code>: This is part of the Raspberry Pi's <code>libcamera</code> stack, and it handles video recording.</li> <li><code>--nopreview</code>: Tells the system not to open a preview window because the script in running in the background in headless mode.</li> <li><code>--width 640 --height 480</code>: Sets the video resolution to 640\u00d7480 pixels. A lower resolution means smaller files and faster processing. You could change this to <code>--width 1280 --height 720</code> or higher for better quality but doing so uses up more computer resources.</li> <li><code>--bitrate 1000000</code>: Sets the video compression level to 1,000,000 bits per second (that is, 1 Mbps). A higher bitrate means better video quality but larger files. For better visuals, you could increase this to 3000000.</li> <li><code>----timeout $DURATION</code>: This sets how long the video recording lasts in milliseconds. You've already specified the value through the <code>$DURATION</code> variable.</li> <li><code>-o \"$SAVE_PATH/ve_$TIMESTAMP.h264\"</code>: Specifies where to save the video file and with what name. <code>\"$SAVE_PATH\"</code> is a variable holding your directory (for example, <code>/home/oracle/Pictures</code>). <code>ve_$TIMESTAMP.h264</code> names the file with a timestamp (like <code>ve_20250420_135030.h264</code>). <code>.h264</code> is the raw video format. You can convert it to <code>.mp4</code> if needed.</li> </ul>"},{"location":"topics/security_camera_steps/#troubleshooting-the-code","title":"Troubleshooting the code","text":"<p>No output</p> <p>If you don't see any <code>test.jpg</code> in the <code>Videos</code> directory, or if you don't see any messages on the terminal window, it's likely that the <code>libcamera</code> package wasn't installed properly. Reinstall it by running the following commands one after the other.</p> <ol> <li>Remove the existing packages: <code>sudo apt purge libcamera0 libcamera-apps libcamera-ipa libcamera0.4</code>.</li> <li>Clean up the cache: <code>sudo apt autoremove</code> and then <code>sudo apt clean</code>.</li> <li>Update the package list: <code>sudo apt update</code>.</li> <li>Install everything afresh: <code>sudo apt install libcamera-apps</code>.</li> </ol>"},{"location":"topics/security_camera_steps/#refine-the-project","title":"Refine the project","text":"<p>Now that your surveillance camera is working, consider the following enhancements.</p> <ul> <li>Never lose a frame</li> <li>Keep cool</li> <li>Stop elegantly</li> <li>Back up</li> </ul>"},{"location":"topics/security_camera_steps/#never-lose-a-frame","title":"Never lose a frame","text":"<p>You might have noticed that the videos have timestamps like this:</p> <pre><code>ve_20250420_122534.h264\nve_20250420_122644.h264\nve_20250420_122753.h264\nve_20250420_122903.h264\n</code></pre> <p>You're losing about 9 to 10 seconds between each video.</p> <pre><code>ve_20250420_122534  \u2192 12:25:34\nve_20250420_122644  \u2192 12:26:44  \u2192 +1 min 10 sec\nve_20250420_122753  \u2192 12:27:53  \u2192 +1 min 9 sec\nve_20250420_122903  \u2192 12:29:03  \u2192 +1 min 10 sec\n</code></pre> <p>Even though you're capturing 1-minute videos, the next one doesn't start immediately at the end of the previous one. Rather, there's a small delay while one <code>libcamera-vid</code> command finishes and the next one starts. But a lot can happen in 10 seconds! To not lose any frames, use a background recording, by tweaking the bash script a bit.</p> <pre><code>#!/bin/bash\nSAVE_PATH=\"/home/oracle/Videos\"\nmkdir -p \"$SAVE_PATH\"\n\nwhile true; do\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout 60000 -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\" &amp;\n  wait\ndone\n</code></pre> <p>Notice the following difference:</p> <pre><code>  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout 60000 -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\" &amp;\n  wait\n</code></pre> <p>Here:</p> <ul> <li><code>----timeout 60000</code>: This sets how long the video recording lasts in milliseconds. 60000 ms means 60 seconds (1 minute). You can change this to however long you want each video segment to be.</li> <li><code>&amp;</code>: This little symbol at the end means the command should be run in the background, so that the script doesn't pause while the video is recording; rather, it moves on and prepares for the next loop.</li> <li><code>wait</code>: This pauses the script for the timeout duration until tha background command finishes. When the video recording ends, the script continues.</li> </ul> <p>This change slightly reduces how long it takes for the next loop to begin. It is by no means seamless, but it at least reduces the 10s delay to about 2s to 3s.</p>"},{"location":"topics/security_camera_steps/#keep-cool","title":"Keep cool","text":"<p>Security cameras, like Lakshman, don't sleep. This means that the Raspberry Pi computer will be running continuously, days on end. If you live in an area like mine, where summer temperatures can cross 50 degrees centigrade, you'd like to ensure that the camera hanging outside doesn't get too hot (Lakshman was known to be extremely hot-tempered, though). Consider using an aluminium heat sink made specially for Raspberry Pi Zero W.</p>"},{"location":"topics/security_camera_steps/#stop-elegantly","title":"Stop elegantly","text":"<p>To stop the bash command that you started with <code>./simplevideo.sh</code>, you press Ctrl + C in the terminal window. Oftentimes, you might see that the script automatically start recording again. This happens because of the following line in your script:</p> <pre><code>libcamera-vid ... &amp;\nwait\n</code></pre> <p><code>&amp;</code> puts <code>libcamera-vid</code> in the background. <code>wait</code> then pauses until that background process finishes. <code>while true</code> restarts the loop. Endlessly. When you press Ctrl + C, your action sends an interrupt signal (called <code>SIGINT</code> in the Debian world) to the foreground process (the <code>wait</code> command). But because <code>libcamera-vid</code> is running in the background, it may not receive that signal and, therefore, the loop continues and restarts the background recording.</p> <p>To handle this situation gracefully, set a trap to catch the interrupt signal in the bash script. The modified script should look like this:</p> <pre><code>#!/bin/bash\nSAVE_PATH=\"/home/dwarpal/Videos\"\nmkdir -p \"$SAVE_PATH\"\n\n# Trap Ctrl+C (SIGINT)\ntrap \"echo 'Stopping...'; kill 0; exit\" SIGINT\n\nwhile true; do\n  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n  libcamera-vid --nopreview --width 640 --height 480 --bitrate 1000000 --timeout 60000 -o \"$SAVE_PATH/ve_$TIMESTAMP.h264\" &amp;\n  wait\ndone\n</code></pre> <p>Notice the new bit, which is on lines 4 and 5. <code>trap ... SIGINT</code> listens for Ctrl + C. <code>kill 0</code> sends a signal to all processes in the current script group so that it kills the background <code>libcamera-vid</code> and stops the loop. <code>exit</code> stops the script elegantly. <code>echo</code> prints a message on the terminal.</p>"},{"location":"topics/security_camera_steps/#back-up","title":"Back up","text":"<p>Because this project is about surveillance, you wouldn't want to lose files before you've seen them. The Raspberry Pi Zero is a marvellous computer, but its limited resources means that you can't really connect a screen to it and keep viewing the video files without drawing upon too much of its resources. An alternative is to move the files to another computer and view them at leisure.</p> <ul> <li>Manually transfer the videos to a different computer</li> <li>Automatically upload the videos to a cloud storage</li> </ul>"},{"location":"topics/security_camera_steps/#manual-transfer-to-another-computer","title":"Manual transfer to another computer","text":"<p>...still being written...</p>"},{"location":"topics/security_camera_steps/#automatic-upload-to-a-cloud-storage","title":"Automatic upload to a cloud storage","text":"<p>Use the <code>rclone</code> package to point to your cloud storage, and then create a cronjob that automatically moves the files from Raspberry Pi to cloud storage at the specified time. This task has several steps.</p> <ol> <li>Install rclone on the laptop.</li> <li>Install rclone on Raspberry Pi.</li> <li>Connect rclone to your cloud storage.</li> <li>Write a bash script to upload videos to cloud storage.</li> <li>Create a cron job to automatically run this bash script.</li> </ol> <p>The details are here:</p> <ol> <li>Switch on your laptop and install <code>rclone</code> on it:<ol> <li>Go to the rclone downloads page and download the <code>.zip</code> file for your Windows laptop.</li> <li>Extract the content to any folder, for example, <code>C:/rclone</code>. Make a note of this folder because you'll need it in a subsequent step.</li> </ol> </li> <li>Switch on your Raspberry Pi, log into it by using Connect on your laptop, and then open a terminal window on Raspberry and install <code>rclone</code> by running the following command commands one after the other:<ol> <li><code>sudo apt update</code>: To find all patches and fixes since the last time that the Raspberry Pi was updated</li> <li><code>sudo apt upgrade -y</code>: To download and install the packs identified in the previous step.</li> <li><code>sudo apt install rclone -y</code>: To install <code>rclone</code>.</li> </ol> </li> <li> <p>Connect <code>rclone</code> to your cloud store:</p> <ol> <li>Start the configuration process by running the following command: <code>rclone config</code>.</li> <li>At the first prompt, type <code>n</code> (for <code>New remote</code>). </li> <li>Specify a name for the connection, for example, <code>gdrive</code>. Make a note of this name because you'll need it soon in a subsequent step.</li> <li>Scroll through the long list that you're presented with and identify the number for the cloud storage service. Then, type the number.</li> <li>Leave the fields for <code>Client ID</code> and <code>Secret</code> blank by entering nothing and pressing Enter.</li> <li>For the scope of access, enter <code>1</code> for full access.</li> <li>Leave the fields for <code>Root Folder ID</code> and <code>Service Account File</code> blank by entering nothing and pressing Enter.</li> <li>Say <code>No</code> to advanced config. Say <code>No</code> to auto-config as well. You'll be given a command for authorising <code>rclone</code>, for example, <code>rclone authorize \"drive\" \"abCdE12wfGH3IjKlmNOpQr4\"</code>. Copy that command.</li> <li> <p>Return to your laptop, open the command prompt, and go to the folder where you extracted <code>rclone</code> to. Paste the command that you copied from Raspberry Pi. You're given a verification code.   </p> </li> <li> <p>Copy the verification code, return to the Raspberry Pi terminal, and paste it. You see a confirmation message. If asked whether to configure the setup as a shared drive, respond in the negative. Enter <code>y</code>, and then exit the configuration setup by entering <code>q</code>.</p> </li> <li>Test the connection by running the following commands one after the other. You should see a folder called <code>rclonetest</code> in your cloud storage with a file called <code>testfile.txt</code> that has a single line saying <code>Testing rclone setup</code>. Before running the commands, replace <code>gdrive</code> with the name of your cloud storage. You made a note of this name in a previous step.</li> <li><code>echo \"Testing rclone setup\" &gt; testfile.txt</code></li> <li><code>rclone copy testfile.txt gdrive:rclonetest</code></li> <li>... still writing ...</li> </ol> </li> </ol>"}]}